<!DOCTYPE html>
<html lang="zh">

<head>
  <title>触摸事件 - 版本 2</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <link href="https://www.w3.org/2008/site/images/favicon.ico" rel="icon">
  <meta name="viewport" content="width=device-width" />
  <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
  <script src="https://www.w3.org/Tools/respec/respec-w3c" defer class="remove"></script>
  <script class="remove">
    var respecConfig = {
      // specification status (e.g. WD, LC, NOTE, etc.). If in doubt use ED.
      specStatus: "UD",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "touch-events",

      // if your specification has a subtitle that goes below the main
      // formal title, define it here
      // subtitle   :  "an excellent document",

      // if you wish the publication date to be other than today, set this
      // publishDate:  "2014-05-29",

      // if the specification's copyright date is a range of years, specify
      // the start date here:
      // copyrightStart: "2005"

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      previousPublishDate: "2013-10-10",
      previousMaturity: "REC",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI: "https://w3c.github.io/touch-events/",
      license: "w3c-software-doc",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2013-02-14",
      // prEnd: "2013-06-06",

      // editors, add as many as you like
      // only "name" is required
      editors: [{
        name: "Doug Schepers",
        url: "http://schepers.cc/",
        company: "W3C",
        companyURL: "http://w3.org/",
      },
      {
        name: "Sangwhan Moon",
        company: "Opera Software ASA",
        companyURL: "http://www.opera.com/",
      },
      {
        name: "Matt Brubeck",
        url: "http://limpet.net/mbrubeck/",
        company: "Mozilla",
        companyURL: "http://www.mozilla.org/",
      },
      {
        name: "Arthur Barstow",
        company: "Invited Expert",
        companyURL: "https://twitter.com/afbarstow",
      },
      {
        name: "Rick Byers",
        url: "http://rbyers.net/",
        company: "Google",
        companyURL: "https://www.google.com/",
      },
      {
        name: "Patrick H. Lauke",
        company: "TetraLogical",
        companyURL: "https://tetralogical.com/",
      },
      ],
      otherLinks: [{
        key: "仓库",
        data: [{
          value: "github项目仓库.",
          href: "https://github.com/w3c/touch-events",
        },
        {
          value: "bug归档.",
          href: "https://github.com/w3c/touch-events/issues",
        },
        {
          value: "提交提示.",
          href: "https://github.com/w3c/touch-events/commits/gh-pages",
        },
        {
          value: "邮件地址.",
          href: "http://lists.w3.org/Archives/Public/public-touchevents/",
        },
        ],
      },
      {
        key: "翻译",
        data: [{
          value: "mangwu.",
          href: "mailto:1185956753@qq.com",
        },
        {
          value: "github项目仓库.",
          href: "https://github.com/mangwu/touch-events-zh",
        },
        ],
      },
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.

      //authors:  [
      //    { name: "Your Name", url: "http://example.org/",
      //      company: "Your Company", companyURL: "http://example.com/" },
      //],

      // Name of the group
      group: "touchevents",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      // wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/45559/status",

      // Enables automatic linking
      xref: ["html", "dom", "infra", "uievents"],
    }
  </script>
  <script id="fixuphook">
      ;
    (function () {
      // Hacky fix-up hook to patch up return types generated by respec.js, as special
      // operations like the ones in specialOps are not officially supported.
      var specialOps = [
        "getter ",
        "setter ",
        "creator ",
        "deleter ",
        "caller ",
        "omittable ",
      ]
      var fixUpCaller = window.setInterval(function () {
        // Check if respec.js is done.
        var respecJS = document.querySelectorAll(".remove")
        if (respecJS.length > 0) return
        else {
          // Performance-wise, this is a stupid idea. For long specs it's probably
          // going to take a *extremely* long time to finish. You have been warned.
          var tags = document.getElementsByTagName("a")

          for (var i = 0; i < tags.length; i++)
            for (var j = 0; j < specialOps.length; j++)
              if (
                tags[i].textContent.indexOf(specialOps[j]) === 0 &&
                tags[i].parentNode.previousSibling.textContent.indexOf(
                  "Return type:"
                ) !== -1
              )
                tags[i].textContent = tags[i].textContent.substring(
                  specialOps[j].length - 1
                )

          // Clean-up script element and interval caller
          var fixUpEl = document.getElementById("fixuphook")
          fixUpEl.parentNode.removeChild(fixUpEl)

          window.clearInterval(fixUpCaller)
        }
      }, 100)
    })()
  </script>

  <style>
    .event {
      font-family: monospace;
      color: #459900;
    }

    pre.idl {
      white-space: pre-wrap;
    }

    .simple th[scope="row"] a {
      color: inherit;
    }
  </style>
  <link rel="stylesheet" href="./override.css" />
</head>

<body>
  <section id="sotd">
    <p>
      通过发布本提案， W3C 希望这个触摸接口提案(Touch Interface Recommendation)
      中的功能性规定不会受到 HTML5 或 Web IDL 更改的影响，
      因为这些规范将继续遵守(proceed to)本提案。工作组已经完成并核准了本规范的
      <a href="http://w3c-test.org/webevents/tests/touch-events-v1/approved/">
        测试套件 </a>，并创建了一份
      <a href="http://www.w3.org/2010/webevents/wiki/TEv1ImplReport">
        实现报告 </a>，显示两个或多个独立的实现是否通过了每种测试。
      此版本的规范包括对<a href="http://www.w3.org/TR/touch-events/">
        第一个版本(Level 1) </a>的修复和改进，并包含了之前作为
      <a href="http://www.w3.org/TR/touch-events-extensions/">
        触摸事件扩展(Touch Event Extensions)</a>发布的特性。
    </p>

    <p>
      (本提案)作为非官方草案出版并不意味着拥有
      <abbr title="World Wide Web Consortium">W3C</abbr>
      及其成员的背书(endorsement)。
    </p>

    <p>
      这是一份草案文件，可能随时被其他文件更新、替换或作废。
      本文档不适合被其它正在编写的规范作为引用。
    </p>

    <p>
      本文档由一个根据
      <a href="https://www.w3.org/Consortium/Patent-Policy-20200915/">
        <abbr title="World Wide Web Consortium">W3C</abbr> 专利政策</a>
      运作的小组编写。<abbr title="World Wide Web Consortium">W3C</abbr>
      保留了一份与该小组可交付成果相关的
      <a href="https://www.w3.org/2004/01/pp-impl/114929/status" rel="disclosure">
        所有可披露专利的公开列表 </a> ;该页面还包括公开一份专利的说明。
      对认为包含
      <a href="https://www.w3.org/Consortium/Patent-Policy-20200915/#def-essential">
        基本权利要求 </a> (Essential Claim(s))的专利有实际了解的个人必须根据
      <a href="https://www.w3.org/Consortium/Patent-Policy-20200915/#sec-Disclosure">
        <abbr title="World Wide Web Consortium">W3C</abbr>专利政策第6节 </a>
      公开信息。
    </p>

    <p>
      本文件受
      <a id="w3c_process_revision" href="https://www.w3.org/2023/Process-20230612/">
        2023 6月12日 <abbr title="World Wide Web Consortium">W3C</abbr>
        处理文档</a> 规范管理。
    </p>
  </section>

  <section id="abstract">
    <p>
      触摸事件规范定义了一组低级别(low-level)事件，
      其表示与触摸敏感平面的一个或多个接触点，以及这些点就触摸表面和在其上的显示
      (例如，触摸屏)或与其相关联(例如，对于没有显示器的绘图板)
      的任何DOM元素而言的变化。它还涉及笔式平板电脑设备，如绘图平板电脑，
      并要考虑到手写笔的功能。
    </p>
  </section>

  <section id="introduction" class="informative">
    <h2>简介</h2>

    <p>
      在提供触摸输入以便让用户使用 Web 应用程序的终端上运行的用户代理，
      通常使用解释执行(interpreted)的鼠标事件使得用户访问交互式的 Web
      应用程序成为可能。然而，
      这些被解释执行的事件是基于物理触摸输入的标准化数据的，
      在提供预期的用户体验方面往往具有局限性。此外，由于鼠标事件的限制
      (既包括系统级的限制，也包括遗留兼容性局限)，无论设备功能如何，
      都不可能处理并发输入(concurrent input)。
    </p>

    <p>
      同时，本地应用程序能够通过提供的系统 APIs 处理这两种情况。
    </p>

    <p>
      触摸事件规范通过声明(specifying)接口以允许 Web 应用程序直接处理触摸事件，
      并为兼容设备(capable devices)提供多个触摸点，从而为该问题提供一种解决方案。
    </p>
  </section>

  <section id="conformance">
    <p>
      除了标记为非规范性的章节外，本规范中的所有创作指南、图表、
      示例和注释都是非规范性。本规范中的其他内容均为规范性内容。
    </p>
    <p>
      本文档中的关键字 <em class="rfc2119">MUST</em> 应按照
      <a href="https://datatracker.ietf.org/doc/html/bcp14">BCP 14</a>
      [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="RFC中用于指示需求级别的关键词">RFC2119</a></cite>]
      [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174"
          title="RFC 2119关键字中大写与小写的歧义">RFC8174</a></cite>]
      中的描述进行解释，当且仅当它们以所有字母都是大写出现时，如前所示。
    </p>
    <p>
      本规范定义了适用于单个产品(a single product)的一致性标准:
      实现其包含的接口的用户代理。
    </p>

    <p>WindowProxy 是在 [[!HTML5]] 中定义的。</p>

    <h3 id="webidl-conform">WebIDL 一致性</h3>
    <p>
      本规范中的 IDL 块是符合 WebIDL 规范 [[!WEBIDL]] 定义的 IDL 片段的。
    </p>

    <p>
      符合要求的用户代理也必须是一个
      <a href="http://www.w3.org/TR/WebIDL/#dfn-conforming-ECMAScript-implementation">
        符合 ECMAScript 的实现</a>(本规范中定义的IDL片段的都符合 ECMAScript )，
      但以下情况除外:
    </p>

    <ul>
      <li>
        <a href="http://www.w3.org/TR/WebIDL/#es-attributes">Web IDL的4.4.6节</a>
        要求 IDL 属性作为访问器属性反映(reflected)在接口的原型对象上。与之相反，
        用户代理可以将 IDL 属性反映为实现相关接口的平台对象上的数据属性。
        这些数据属性在获取和设置时必须表现出与调用平台对象上的访问器属性的
        getter 和 setter 时相同的行为。
      </li>
    </ul>
    <p>
      <strong>注意:</strong> 反映 IDL
      属性的两种方式都允许简单地获取和设置平台对象上的属性以使其工作。例如，
      给定一个 <code>Touch</code> 对象 <code>aTouch</code> ，预估(evaluating)
      <code>aTouch.target</code> 为返回 <code>Touch</code> 对象的
      <code>EventTarget</code> 。如果用户代理将 IDL 属性实现为访问器属性，
      那么访问属性将调用返回 <code>EventTarget</code> 的 getter 。
      如果用户代理在平台对象上，以与访问器属性相同的行为，将 IDL
      属性实现为数据属性，则该对象将拥有一个属性名称为 <code>target</code>
      的自有属性，该属性的值为 <code>EventTarget</code> 对象，
      并且访问属性将返回该值。
    </p>
  </section>

  <section>
    <h2><dfn>Touch</dfn> 接口</h2>
    <p>
      此接口描述触摸事件的单个 <a>touch point</a> 。<a><code>Touch</code></a>
      对象是不可变的(immutable); 创建后，其属性不得更改。
    </p>
    <pre class="idl">
enum TouchType {
    "direct",
    "stylus"
};

dictionary TouchInit {
    required long        identifier;
    required EventTarget target;
             double      clientX = 0;
             double      clientY = 0;
             double      screenX = 0;
             double      screenY = 0;
             double      pageX = 0;
             double      pageY = 0;
             float       radiusX = 0;
             float       radiusY = 0;
             float       rotationAngle = 0;
             float       force = 0;
             double      altitudeAngle = 0;
             double      azimuthAngle = 0;
             TouchType   touchType = "direct";
};

[Exposed=Window]
interface Touch {
    constructor(TouchInit touchInitDict);
    readonly        attribute long        identifier;
    readonly        attribute EventTarget target;
    readonly        attribute double      screenX;
    readonly        attribute double      screenY;
    readonly        attribute double      clientX;
    readonly        attribute double      clientY;
    readonly        attribute double      pageX;
    readonly        attribute double      pageY;
    readonly        attribute float       radiusX;
    readonly        attribute float       radiusY;
    readonly        attribute float       rotationAngle;
    readonly        attribute float       force;
    readonly        attribute float       altitudeAngle;
    readonly        attribute float       azimuthAngle;
    readonly        attribute TouchType   touchType;
};
      </pre>
    <dl data-dfn-for="Touch" data-link-for="Touch">
      <dt><dfn>identifier</dfn></dt>
      <dd>
        <p>每个 <a>touch point</a> 的标识符数字。</p>
        <p>
          当一个触摸点活跃时，必须为其分配一个不同于其他任何
          <a>active touch point</a> 的 <a>identifier</a> 。
          当触摸点保持活跃时，所有引用它的事件都必须为它分配相同的
          <a>identifier</a> 。
        </p>
      </dd>

      <dt><dfn>target</dfn></dt>
      <dd>
        <p>
          <a>touch point</a> 所在的 <code>EventTarget</code> ，
          从它第一次放置在触摸平面上时开始记录，即使 <a>touch point</a>
          已经移动到该元素(事件对象)的交互区域之外。
        </p>
        <div class="note">
          一些实现会变更(alter)目标元素以校正粗略输入(coarse input)的不精确性。
          因此，目标元素不一定是直接位于事件坐标处的元素。用于针对/消除
          (target/disambiguate)粗略输入的歧义的方法超出了本规范的讨论范围。
        </div>
      </dd>

      <dt><dfn>screenX</dfn></dt>
      <dd>
        <p>
          触摸点相对于屏幕的水平坐标(以像素为单位)
        </p>
      </dd>
      <dt><dfn>screenY</dfn></dt>
      <dd>
        <p>
          触摸点相对于屏幕的垂直坐标(以像素为单位)
        </p>
      </dd>

      <dt><dfn>clientX</dfn></dt>
      <dd>
        <p>
          触摸点相对于视口的水平坐标(以像素为单位)，不包括任何的滚动偏移量
        </p>
      </dd>
      <dt><dfn>clientY</dfn></dt>
      <dd>
        <p>
          触摸点相对于视口的垂直坐标(以像素为单位)，不包括任何的滚动偏移量
        </p>
      </dd>

      <dt><dfn>pageX</dfn></dt>
      <dd>
        <p>
          触摸点点相对于视口的水平坐标(以像素为单位)，包括任何存在的滚动偏移量
        </p>
      </dd>
      <dt><dfn>pageY</dfn></dt>
      <dd>
        <p>
          触摸点点相对于视口的垂直坐标(以像素为单位)，包括任何存在的滚动偏移量
        </p>
      </dd>
      <dt><dfn>radiusX</dfn></dt>
      <dd>
        <p>
          一个椭圆的水平轴半径，该椭圆是沿着 rotationAngle
          指示的轴最紧密地包围触摸区域(例如手指、触笔)构成的最小椭圆，
          属性单位为与 screenX 相同比例的 CSS 像素(由[[!CSS-VALUES]]定义);
          如果值未知，则为 <code>0</code> 。该值不能为负数。
        </p>
      </dd>
      <dt><dfn>radiusY</dfn></dt>
      <dd>
        <p>
          一个椭圆的垂直轴半径，该椭圆是沿着 rotationAngle
          指示的轴最紧密地包围触摸区域(例如手指、触笔)构成的最小椭圆，
          属性单位为与 screenX 相同比例的 CSS 像素(由[[!CSS-VALUES]]定义);
          如果值未知，则为 <code>0</code> 。该值不能为负数。
        </p>
      </dd>
      <dt><dfn>rotationAngle</dfn></dt>
      <dd>
        <p>
          由 radiusX 和 radiusY 描述的椭圆绕其中心顺时针旋转的角度(以度为单位);
          如果值未知，则为 <code>0</code> 。该值必须大于或等于 <code>0</code>
          且小于 <code>90</code> 。
        </p>

        <p>
          如果由 radiusX 和 radiusY 描述的椭圆是圆形的，则 rotationAngle
          的值不会影响(触摸点)。在这种情况下，用户代理可以使用 <code>0</code>
          作为值，也可以使用允许范围内的任何其他值。(例如，
          用户代理可以使用上一次触摸事件的 rotationAngle 值，以避免突然的变化。)
        </p>

        <div class="note custom-note">
          由 radiusX 和 radiusY 描述的正方向的椭圆，通过顺时针旋转这个角度后，
          能最精确地覆盖住用户和触摸平面的接触面的角度。
          这个值可能从 0 到 90。这三个值一起描述了用户和触摸平面的接触面的形状的大小。
        </div>
      </dd>
      <dt><dfn>force</dfn></dt>
      <dd>
        <p>
          施加的压力的相对值，在 <code>0</code> 到 <code>1</code> 的范围内，其中
          <code>0</code> 是无压力， <code>1</code>
          是触摸设备能够感测的最高压力水平; 如果值未知，则为 <code>0</code> 。
          在已知的力的环境中，由 force
          属性表示的绝对压力和压力级别的灵敏度可能会稍有调整。
        </p>
      </dd>
      <dt><dfn>altitudeAngle</dfn></dt>
      <dd>
        <p>
          传感器(例如电子笔/手写笔)的俯仰角(以弧度为单位)，范围为 [0，π/2] —
          其中 0 表示(笔)平行于触摸平面(X-Y平面)， π/2 表示(笔)垂直于触摸平面。
          对于不报告或不支持倾斜度(tilt)或角度的硬件和平台，该值
          <span class="zh-upper">必须</span> 为 0 。
        </p>

        <div class="note">
          此处为 <code>altitudeAngle</code> 属性定义的默认值为 0 。
          这与 <a href="https://w3c.github.io/pointerevents/">
            指针事件 - 版本 3 </a> [[POINTEREVENTS]] 规范对
          <code>altitudeAngle</code> 属性的定义不同，后者属性的默认值为 π/2 ，
          即将传感器(默认)定位为垂直于平面。
        </div>

        <figure id="figure_altitudeAngle">
          <img src="images/altitudeAngle.png" alt="altitudeAngle属性解释图例" />
          <figcaption>
            <code>altitudeAngle</code> 属性值为 π/4 (相对于 X-Y 平面 45 度)的示例。
          </figcaption>
        </figure>
      </dd>
      <dt><dfn>azimuthAngle</dfn></dt>
      <dd>
        <p>
          表示传感器(transducer，例如电子笔/手写笔)的方位角(以弧度为单位)，
          范围为 [0，2π] — 其中 0 值表示: 一个传感器，其笔帽指向 X-Y 平面上 X
          值增加的方向(如果向下看，则指向 "3点钟" 方向)，顺时针方向时，
          值逐渐增加( "6点钟" 处值为的 π/2 ， "9点钟" 处值为 π ， "12点钟"
          处值为 3π/2 )。当传感器完全垂直于表面(俯仰角，也就是
          <code>altitudeAngle</code> 为 π/2 )时，该值 <span class="zh-upper">
            必须</span> 为 0 。对于不报告倾斜或角度的硬件和平台，该值
          <span class="zh-upper">必须</span> 为 0 。
        </p>
        <figure id="figure_azimuthAngle">
          <img src="images/azimuthAngle.png" alt="azimuthAngle explanation diagram" />
          <figcaption>
            Example <code>azimuthAngle</code> of π/6 ("4 o'clock").
          </figcaption>
        </figure>
      </dd>
      <dt><dfn>touchType</dfn></dt>
      <dd>
        <p>用于触发触摸的设备类型。</p>
      </dd>
    </dl>
    <dl>
      <dt><dfn>TouchType</dfn></dt>
      <dd>
        <p>
          枚举类型，表示触摸输入可能的不同类型。
        </p>
      </dd>
    </dl>
    <dl data-dfn-for="TouchType" data-link-for="TouchType">
      <dt><dfn>direct</dfn></dt>
      <dd>
        <p>
          TouchType 枚举的一种触摸输入类型，字符串，表示手指在屏幕上的直接触摸。
        </p>
      </dd>
      <dt><dfn>stylus</dfn></dt>
      <dd>
        <p>
          TouchType 枚举的一种触摸输入类型，字符串，表示手写笔或电子笔设备的触摸。
        </p>
      </dd>
    </dl>
  </section>

  <section>
    <h2><dfn>TouchList</dfn> 接口</h2>
    <p>
      该接口定义了触摸事件的各个(individual)接触点的列表。
      <a><code>TouchList</code></a> 对象是不可变的(immutable); 创建后，
      其内容不得更改。
    </p>
    <p>
      一个 <code>TouchList</code> 对象 <em>支持的属性索引</em> ([[!WEBIDL]])
      是 0 到比列表长度小 1 之间的数字。
    </p>
    <pre class="idl">
[Exposed=Window]
interface TouchList {
    readonly        attribute unsigned long length;
    getter Touch? item (unsigned long index);
};
      </pre>
    <dl data-dfn-for="TouchList" data-link-for="TouchList">
      <dt><dfn>length</dfn></dt>
      <dd>
        <p>
          返回列表中 <a><code>Touch</code></a> 对象的数量
        </p>
      </dd>
      <dt><dfn>item</dfn></dt>
      <dd>
        <p>
          返回列表中指定索引处的 <a><code>Touch</code></a> 对象，
          如果传递的索引值不小于列表长度，则返回 <code>null</code> 。
        </p>
      </dd>
    </dl>
  </section>

  <section>
    <h2><dfn>TouchEvent</dfn> 接口</h2>
    <p>
      此接口定义了 <a><code>touchstart</code></a> 、
      <a><code>touchend</code></a> 、 <a><code>touchmove</code></a> 和
      <a><code>touchcancel</code></a> 事件类型。 <a><code>TouchEvent</code></a>
      对象是不可变的(immutable); 创建并初始化一个后，其属性不得更改。
      <code>TouchEvent</code> 继承自 [[!DOM-LEVEL-3-EVENTS]] 中定义的
      <code>UIEvent</code> 接口。
    </p>
    <p>
      <code>TouchEvent</code> 接口的构造函数使用 <dfn>TouchEventInit</dfn>
      字典提供的一种机制(mechanism)，来构造不可信(合成)的触摸事件。
      它继承自 [[!DOM-LEVEL-3-EVENTS]] 中定义的 <code>EventModifierInit</code>
      字典。 [[!DOM4]] 中定义了构建事件的步骤。
      有关演示如何触发不可信的触摸事件的示例代码，请参阅该
      <a href="#firing-a-synthetic-touchevent-from-script" title="examples">
        示例
      </a> 。
    </p>
    <pre class="idl">
dictionary TouchEventInit : EventModifierInit {
             sequence&lt;Touch&gt; touches = [];
             sequence&lt;Touch&gt; targetTouches = [];
             sequence&lt;Touch&gt; changedTouches = [];
};

[Exposed=Window]
interface TouchEvent : UIEvent {
    constructor(DOMString type, optional TouchEventInit eventInitDict = {});
    readonly        attribute TouchList touches;
    readonly        attribute TouchList targetTouches;
    readonly        attribute TouchList changedTouches;
    readonly        attribute boolean   altKey;
    readonly        attribute boolean   metaKey;
    readonly        attribute boolean   ctrlKey;
    readonly        attribute boolean   shiftKey;
    getter boolean getModifierState (DOMString keyArg);
};
      </pre>
    <dl data-dfn-for="TouchEvent" data-link-for="TouchEvent">
      <dt><dfn>touches</dfn></dt>
      <dd>
        <p>
          表示当前触摸平面上的每个接触点的 <a><code>Touch</code></a> 对象列表。
        </p>
        <div class="note custom-note">
          一个 <a><code>TouchList</code></a> ，
          其会列出所有当前在与触摸表面接触的 <a><code>Touch</code></a> 对象，
          不管触摸点是否已经改变或其目标元素是在处于
          <a><code>touchstart</code></a> 阶段。
        </div>
      </dd>
      <dt><dfn>targetTouches</dfn></dt>
      <dd>
        <p>
          每个接触点的 <a><code>Touch</code></a> 对象列表，
          这些接触点正在接触触摸平面 <em>并且</em>
          是从当前事件目标的元素上开始的。
        </p>
        <div class="note custom-note">
          所谓 "从当前事件目标的元素上开始的" 的意思就是: 这些接触点触发的
          <code>touchstart</code> 事件发生在与当前触发的触摸事件相同的目标元素内。
        </div>
      </dd>
      <dt><dfn>changedTouches</dfn></dt>
      <dd>
        <p>
          为事件做出贡献(contributed)的每个接触点的 <a><code>Touch</code></a>
          对象列表。
        </p>
        <p>
          对于 <a><code>touchstart</code></a> 事件，(该属性的值)
          必须是与当前事件一起刚刚激活(active)的触摸点的列表。
          对于 <a><code>touchmove</code></a> 事件，(该属性的值)
          必须是自上次事件发生以来产生移动的触摸点的列表。对于
          <a><code>touchend</code></a> 和 <a><code>touchcancel</code></a> 事件，
          (该属性的值)必须是刚刚从触摸平面移开的触摸点的列表，
          这些触摸点附带最后移除之前已知坐标信息。
        </p>
      </dd>

      <dt><dfn>altKey</dfn></dt>
      <dd>
        <p>
          如果 alt (Alternate)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code>
        </p>
      </dd>
      <dt><dfn>metaKey</dfn></dt>
      <dd>
        <p>
          如果 meta (Meta)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code> 。在某些平台上，
          此属性可能映射到名称不同的修饰符按键。
        </p>
      </dd>
      <dt><dfn>ctrlKey</dfn></dt>
      <dd>
        <p>
          如果 ctrl (Control)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code>
        </p>
      </dd>
      <dt><dfn>shiftKey</dfn></dt>
      <dd>
        <p>
          如果 shift (Shift)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code>
        </p>
      </dd>
      <dt><dfn>getModifierState</dfn>(keyArg)</dt>
      <dd>
        <p>
          使用键值查询修饰符按键的状态。
          如果它是修饰符按键并且该修饰符按键处于激活状态，则返回
          <code>true</code> ，否则返回 <code>false</code> 。
        </p>
        <div class="note custom-note">
          关于修饰符按键(key modifier)以及键值，可以参阅 [[UIEVENTS]] 和
          [[UIEvents-Key]] 。
        </div>

      </dd>
    </dl>

    <section class="informative">
      <h2>TouchEvent 接口实现者的注释</h2>
      <div class="note">
        <p>
          用户代理应确保来自给定 <a><code>TouchEvent</code></a> 中的所有可用 
          <a><code>Touch</code></a> 对象都与 <a><code>TouchEvent</code></a> 
          被派发到的同一文档相关联。为了实现这一点，用户代理应保留当前
          <em>触摸活动(touch-active)</em> 文档的概念(notion)。在第一次触摸时，
          它(当前 <em>触摸活动(touch-active)</em> 文档)
          被设置为创建触摸的目标文档。当释放完所有活跃的触摸点后，
          <em>触摸活动(touch-active)</em> 文档将被清除。
          所有 <a><code>TouchEvent</code></a> 都被派发到当前 
          <em>触摸活动(touch-active)</em> 文档，并且它(触摸事件)包含的每个 
          <a><code>Touch</code></a> 对象仅引用该文档中的 DOM 元素(和坐标信息)。
          如果触摸完全在当前 <em>触摸活动(touch-active)</em> 文档之外开始，
          则会完全忽略该触摸。
        </p>
      </div>
    </section>

    <section class="informative">
      <h2>用例</h2>

      <p>
        下面的示例演示了 <a><code>TouchEvent</code></a> 中定义的不同 
        <a><code>TouchList</code></a> 成员之间的关系。
      </p>

      <section>
        <h3>
          一个 <a><code>TouchEvent</code></a> 的 <code>touches</code> 和 
          <code>targetTouches</code>
        </h3>

        <p>
          此示例演示了<a><code>TouchEvent</code></a> 接口中定义的 
          <code>touches</code> 和 <code>targetTouches</code> 成员之间的功能
          (utility)和关系。以下代码将根据在可触摸元素(touchable element)
          和文档上的触摸点数量生成不同的输出:
        </p>
        
        <pre class="example">
&lt;div id='touchable'&gt;这个元素是可触摸的。&lt;/div&gt;

&lt;script&gt;
document.getElementById('touchable').addEventListener('touchstart', function(ev) {

    if (ev.touches.item(0) == ev.targetTouches.item(0))
    {
        /**
         * 如果在触摸平面上的第一次触摸的目标元素就是 "可触摸" 元素，
         * 则应执行以下代码。由于 targetTouches 是覆盖整个触摸平面的
         * touches 的子集，因此 TouchEvent.touches >= TouchEvents.targetTouches
         * 始终为 true 。
         */

        document.write('Hello Touch Events!');
    }

    if (ev.touches.length == ev.targetTouches.length)
    {
        /**
         * 如果所有活跃触摸点都在 "可触摸" 元素上，
         * 则长度属性应相同。
         */

        document.write('All points are on target element')
    }

    if (ev.touches.length > 1)
    {
        /**
         * 在单点触摸输入设备上，触摸平面上只能有一个接触点，
         * 因此只有当终端支持多点触摸时，
         * 才能执行以下代码。
         */

        document.write('Hello Multiple Touch!');
    }

}, false);
&lt;/script&gt;
</pre>
      </section>

      <section>
        <h3>
          <code>changedTouches</code> of a <a><code>TouchEvent</code></a>
        </h3>

        <p>
          This example demonstrates the utility of
          <code>changedTouches</code> and it's relation with the other
          <a><code>TouchList</code></a> members of the
          <a><code>TouchEvent</code></a> interface. The code is a example
          which triggers whenever a touch point is removed from the defined
          touchable element:
        </p>

        <pre class="example">
&lt;div id='touchable'&gt;This element is touchable.&lt;/div&gt;

&lt;script&gt;
document.getElementById('touchable').addEventListener('touchend', function(ev) {

    /**
     * Example output when three touch points are on the surface,
     * two of them being on the "touchable" element and one point
     * in the "touchable" element is lifted from the surface:
     *
     * Touch points removed: 1
     * Touch points left on element: 1
     * Touch points left on document: 2
     */

    document.write('Touch points removed: ' + ev.changedTouches.length);
    document.write('Touch points left on element: ' + ev.targetTouches.length);
    document.write('Touch points left on document: ' + ev.touches.length);

}, false);
&lt;/script&gt;
</pre>
      </section>

      <section>
        <h3>
          Firing a synthetic <a><code>TouchEvent</code></a> from script
        </h3>

        <p>
          This example demonstrates how to create and fire a
          <a><code>TouchEvent</code></a> from script.
        </p>

        <pre class="example">

if (Touch.length &lt; 1 || TouchEvent.length &lt; 1)
  throw "TouchEvent constructors not supported";

var touch = new Touch({
    identifier: 42,
    target: document.body,
    clientX: 200,
    clientY: 200,
    screenX: 300,
    screenY: 300,
    pageX: 200,
    pageY: 200,
    radiusX: 5,
    radiusY: 5
});

var touchEvent = new TouchEvent("touchstart", {
    cancelable: true,
    bubbles: true,
    composed: true,
    touches: [touch],
    targetTouches: [touch],
    changedTouches: [touch]
});

document.body.dispatchEvent(touchEvent);
</pre>
      </section>
    </section>

    <section class="informative">
      <h2>
        List of <a><code>TouchEvent</code></a> types
      </h2>

      <p>
        The following table provides a summary of the
        <a><code>TouchEvent</code></a> event types defined in this
        specification. All events should accomplish the bubbling phase. All
        events should be composed [[WHATWG-DOM]] events.
      </p>

      <!--
          // FIXME: As of the time of writing, respec.js doesn't have support for
          // tables like this - we're just piggybacking on a existing class, with
          // raw markup as a quick and dirty workaround.
          -->

      <table class="simple" id="table-event-summary">
        <thead>
          <tr>
            <th>Event Type</th>
            <th>Sync / Async</th>
            <th>Bubbling phase</th>
            <th>Composed</th>
            <th>Trusted proximal event target types</th>
            <th>Interface</th>
            <th>Cancelable</th>
            <th>Default Action</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row">
              <a><code>touchstart</code></a>
            </th>
            <td>Sync</td>
            <td>Yes</td>
            <td>Yes</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td><a href="#cancelability">Varies</a></td>
            <td>undefined</td>
          </tr>
          <tr>
            <th scope="row">
              <a><code>touchend</code></a>
            </th>
            <td>Sync</td>
            <td>Yes</td>
            <td>Yes</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td><a href="#cancelability">Varies</a></td>
            <td>
              Varies: user agents may dispatch
              <a href="#mouse-events">mouse and click events</a>
            </td>
          </tr>
          <tr>
            <th scope="row">
              <a><code>touchmove</code></a>
            </th>
            <td>Sync</td>
            <td>Yes</td>
            <td>Yes</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td><a href="#cancelability">Varies</a></td>
            <td>undefined</td>
          </tr>
          <tr>
            <th scope="row">
              <a><code>touchcancel</code></a>
            </th>
            <td>Sync</td>
            <td>Yes</td>
            <td>Yes</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td>No</td>
            <td>none</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h3 id="cancelability">Cancelability of touch events</h3>
      <p>
        <a href="#dfn-canceled-event">Canceling</a> a touch event can prevent
        or otherwise interrupt scrolling (which could be happening in parallel
        with script execution). For maximum scroll performance, a user agent
        may not wait for each touch event associated with the scroll to be
        processed to see if it will be canceled. In such cases the user agent
        should generate touch events whose <code>cancelable</code> property is
        <code>false</code>, indicating that <code>preventDefault</code> cannot
        be used to prevent or interrupt scrolling. Otherwise
        <code>cancelable</code> will be <code>true</code>.
      </p>
      <p>
        In particular, a user agent should generate only uncancelable touch
        events when it
        <a href="https://dom.spec.whatwg.org/#observing-event-listeners">observes that there are no non-passive
          listeners</a>
        for the event.
      </p>
    </section>

    <section>
      <h3 id="event-touchstart">
        The <dfn class="event"><code>touchstart</code></dfn> event
      </h3>
      <p>
        A user agent must dispatch this event type to indicate when the user
        places a <a>touch point</a> on the touch surface.
      </p>

      <p>
        The target of this event must be an <code>Element</code>. If the touch
        point is within a frame, the event should be dispatched to an element
        in the child browsing context of that frame.
      </p>

      <p>
        If this event is <a href="#dfn-canceled-event">canceled</a>, it should
        prevent any default actions caused by any touch events associated with
        the same <a>active touch point</a>, including mouse events or
        scrolling.
      </p>
    </section>

    <section data-link-for="TouchEvent">
      <h3 id="event-touchend">
        The <dfn class="event"><code>touchend</code></dfn> event
      </h3>
      <p>
        A user agent must dispatch this event type to indicate when the user
        removes a <a>touch point</a> from the touch surface, also including
        cases where the touch point physically leaves the touch surface, such
        as being dragged off of the screen.
      </p>

      <p>
        The target of this event must be the same <code>Element</code> on
        which the <a>touch point</a> started when it was first placed on the
        surface, even if the <a>touch point</a> has since moved outside the
        interactive area of the target element.
      </p>

      <p>
        The <a>touch point</a> or points that were removed must be included in
        the <a><code>changedTouches</code></a> attribute of the
        <a><code>TouchEvent</code></a>, and must not be included in the <a><code>touches</code></a> and
        <a><code>targetTouches</code></a>
        attributes.
      </p>

      <p>
        If this event is <a href="#dfn-canceled-event">canceled</a>, any
        sequence of touch events that includes this event must not be
        <a href="#click-events">interpreted as a click</a>.
      </p>
    </section>

    <section>
      <h3 id="event-touchmove">
        The <dfn class="event"><code>touchmove</code></dfn> event
      </h3>
      <p>
        A user agent must dispatch this event type to indicate when the user
        moves a <a>touch point</a> along the touch surface.
      </p>

      <p>
        The target of this event must be the same <code>Element</code> on
        which the <a>touch point</a> started when it was first placed on the
        surface, even if the <a>touch point</a> has since moved outside the
        interactive area of the target element.
      </p>

      <p>
        Note that the rate at which the user agent sends
        <a><code>touchmove</code></a>
        events is implementation-defined, and may depend on hardware
        capabilities and other implementation details.
      </p>

      <p>
        A user agent should suppress the default action caused by any
        <a><code>touchmove</code></a> event until at least one
        <a><code>touchmove</code></a> event associated with the same
        <a>active touch point</a> is not
        <a href="#dfn-canceled-event">canceled</a>. Whether the default action
        is suppressed for <a><code>touchmove</code></a> events after at least
        one <a><code>touchmove</code></a> event associated with the same
        <a>active touch point</a> is not
        <a href="#dfn-canceled-event">canceled</a> is implementation
        dependent.
      </p>
    </section>

    <section data-link-for="TouchEvent">
      <h3 id="event-touchcancel">
        The <dfn class="event"><code>touchcancel</code></dfn> event
      </h3>
      <p>
        A user agent must dispatch this event type to indicate when a touch
        point has been disrupted in an implementation-specific manner, such as
        a synchronous event or action originating from the UA canceling the
        touch, or the touch point leaving the document window into a
        non-document area which is capable of handling user interactions (e.g.
        the UA's native user interface, or an area of the document which is
        managed by a plug-in). A user agent may also dispatch this event type
        when the user places more <a>touch point</a>s on the touch surface
        than the device or implementation is configured to store, in which
        case the earliest <a><code>Touch</code></a> object in the
        <a><code>TouchList</code></a> should be removed.
      </p>

      <p>
        The target of this event must be the same <code>Element</code> on
        which the <a>touch point</a> started when it was first placed on the
        surface, even if the <a>touch point</a> has since moved outside the
        interactive area of the target element.
      </p>

      <p>
        The <a>touch point</a> or points that were removed must be included in
        the <a><code>changedTouches</code></a> attribute of the
        <a><code>TouchEvent</code></a>, and must not be included in the <a><code>touches</code></a> and
        <a><code>targetTouches</code></a>
        attributes.
      </p>
    </section>
  </section>

  <section>
    <h2>Retargeting</h2>
    <p>
      The following section describes
      <a href="https://dom.spec.whatwg.org/#event-retargeting-steps">retargeting steps</a>, defined in [[!WHATWG-DOM]].
    </p>

    <p>
      <code>Touch</code> object has an associated
      <dfn>unadjustedTarget</dfn> (null or <code>EventTarget</code>). Unless
      stated otherwise it is null.
    </p>

    <p>
      <code>TouchEvent</code>'s
      <a href="https://dom.spec.whatwg.org/#event-retargeting-steps">retargeting steps</a>, given a
      <var>touchEvent</var>, must run these steps:
    </p>
    <ol>
      <li>
        <p>
          For each <a><code>Touch</code></a> <var>touch</var> in
          <var>touchEvent</var>'s <code>touches</code>,
          <code>targetTouches</code>, and <code>changedTouches</code> members:
        </p>
        <ol>
          <li>
            Set <var>touch</var>'s <a><code>unadjustedTarget</code></a> to
            <var>touch</var>'s <code>target</code> if <var>touch</var>'s
            <a><code>unadjustedTarget</code></a> is null.
          </li>
          <li>
            Set <var>touch</var>'s <code>target</code> to the result of
            invoking
            <a href="https://dom.spec.whatwg.org/#retarget">retargeting</a>
            <var>touch</var>'s <a><code>unadjustedTarget</code></a> against
            <var>touchEvent</var>'s <code>target</code>.
          </li>
        </ol>
      </li>
    </ol>
  </section>

  <section>
    <h2>Conditionally exposing legacy touch event APIs</h2>
    <p>
      User agents have an associated boolean
      <dfn data-export="">expose legacy touch event APIs</dfn> whose value is
      <a>implementation-defined</a>.
    </p>

    <p class="note">
      Existing web content often use the existence of these APIs as a signal
      that the user agent is a touch-enabled "mobile" device, and therefore
      exposing these APIs on non-mobile devices, even if they are
      touch-enabled, could lead to a suboptimal user experience for such web
      content.
    </p>
  </section>

  <section>
    <h2>Extensions to the <code>GlobalEventHandlers</code> mixin</h2>
    <p>
      The following section describes extensions to the existing
      <dfn data-cite="HTML5#globaleventhandlers">GlobalEventHandlers</dfn>
      mixin, defined in [[!HTML5]], to facilitate the event handler
      registration. For user agents where
      <a>expose legacy touch event APIs</a> is false, this mixin must not be
      implemented.
    </p>
    <pre class="idl">
partial interface mixin GlobalEventHandlers {
                    attribute EventHandler ontouchstart;
                    attribute EventHandler ontouchend;
                    attribute EventHandler ontouchmove;
                    attribute EventHandler ontouchcancel;
};
      </pre>
    <dl data-dfn-for="GlobalEventHandlers" data-link-for="GlobalEventHandlers">
      <dt><dfn>ontouchstart</dfn></dt>
      <dd>
        <p>
          The event handler IDL attribute (see [[!HTML5]]) for the
          <code>touchstart</code> event type.
        </p>
      </dd>
      <dt><dfn>ontouchend</dfn></dt>
      <dd>
        <p>
          The event handler IDL attribute (see [[!HTML5]]) for the
          <code>touchend</code> event type.
        </p>
      </dd>
      <dt><dfn>ontouchmove</dfn></dt>
      <dd>
        <p>
          The event handler IDL attribute (see [[!HTML5]]) for the
          <code>touchmove</code> event type.
        </p>
      </dd>
      <dt><dfn>ontouchcancel</dfn></dt>
      <dd>
        <p>
          The event handler IDL attribute (see [[!HTML5]]) for the
          <code>touchcancel</code> event type.
        </p>
      </dd>
    </dl>
  </section>

  <section id="mouse-events">
    <h2>Interaction with Mouse Events and <code>click</code></h2>
    <p>
      The user agent may dispatch both touch events and (for compatibility
      with web content not designed for touch) mouse events
      [[!DOM-LEVEL-2-EVENTS]] in response to the same user input. If the user
      agent dispatches both touch events and mouse events in response to a
      single user action, then the <a><code>touchstart</code></a> event type
      must be dispatched before any mouse event types for that action. If
      <a><code>touchstart</code></a>, <a><code>touchmove</code></a>, or <a><code>touchend</code></a> are
      <a href="#dfn-canceled-event">canceled</a>, the user agent should not
      dispatch any mouse event that would be a consequential result of the
      prevented touch event.
    </p>

    <p class="note">
      If a Web application can process touch events, it can
      <a href="#dfn-canceled-event">cancel</a> the events, and no
      corresponding mouse events would need to be dispatched by the user
      agent. If the Web application is not specifically written for touch
      input devices, it will react to the subsequent mouse events instead.
    </p>

    <p class="note">
      User agents will typically dispatch mouse and click events only for
      single-finger activation gestures (like tap and long press). Gestures
      involving movement of the touch point or multi-touch interactions – with
      two or more
      <a href="#dfn-active-touch-point">active touch points</a> – will usually
      only generate touch events.
    </p>

    <p id="click-events">
      If the user agent interprets a sequence of touch events as a tap
      gesture, then it should dispatch <code>mousemove</code>,
      <code>mousedown</code>, <code>mouseup</code>, and
      <code>click</code> events (in that order) at the location of the
      <a><code>touchend</code></a> event for the corresponding touch input. If
      the contents of the document have changed during processing of the touch
      events, then the user agent may dispatch the mouse events to a different
      target than the touch events.
    </p>

    <p>
      The default actions and ordering of any further touch and mouse events
      are implementation-defined, except as specified elsewhere.
    </p>

    <div class="note">
      <p>
        The activation of an element (e.g., in some implementations, a tap)
        would typically produce the following event sequence (though this may
        vary slightly, depending on specific user agent behavior):
      </p>
      <ol data-class="note-list">
        <li><code>touchstart</code></li>
        <li>
          Zero or more <code>touchmove</code> events, depending on movement of
          the finger
        </li>
        <li><code>touchend</code></li>
        <li>
          <code>mousemove</code>
          <small>(for compatibility with legacy mouse-specific code)</small>
        </li>
        <li><code>mousedown</code></li>
        <li><code>mouseup</code></li>
        <li><code>click</code></li>
      </ol>
      <p>
        If, however, either the <code>touchstart</code>,
        <code>touchmove</code> or <code>touchend</code> event has been
        <a href="#dfn-canceled-event">canceled</a> during this interaction, no
        mouse or click events will be fired, and the resulting sequence of
        events would simply be:
      </p>
      <ol data-class="note-list">
        <li><code>touchstart</code></li>
        <li>
          Zero or more <code>touchmove</code> events, depending on movement of
          the finger
        </li>
        <li><code>touchend</code></li>
      </ol>
    </div>

    <div class="note">
      <p>
        Even if a user agent supports Touch Events, this does not necessarily
        mean that a touchscreen is the only input mechanism available to
        users. Particularly in the case of touch-enabled laptops, or
        traditional "touch only" devices (such as phones and tablets) with
        paired external input devices, users may use the touchscreen in
        conjunction with a trackpad, mouse or keyboard. For this reason,
        developers should avoid binding event listeners with "either touch or
        mouse/keyboard" conditional code, as this results in sites/application
        that become touch-exclusive, preventing users from being able to use
        any other input mechanism.
      </p>
      <pre class="example"><code>
// conditional "touch OR mouse/keyboard" event binding
// DON'T DO THIS, as it makes interactions touch-exclusive
// on devices that have both touch and mouse/keyboard

if ('ontouchstart' in window) {
  // set up event listeners for touch
  target.addEventListener('touchend', ...);
  ...
} else {
  // set up event listeners for mouse/keyboard
  target.addEventListener('click', ...);
  ...
}
</code></pre>
      <p>
        Instead, developers should handle different forms of input
        concurrently.
      </p>
      <pre class="example"><code>
// concurrent "touch AND mouse/keyboard" event binding

// set up event listeners for touch
target.addEventListener('touchend', function(e) {
  // prevent compatibility mouse events and click
  e.preventDefault();
  ...
});
...

// set up event listeners for mouse/keyboard
target.addEventListener('click', ...);
...
</code></pre>
      <p>
        To avoid processing the same interaction twice for touch (once for the
        touch event, and once for the compatibility mouse events), developers
        should make sure to <a href="#dfn-canceled-event">cancel</a> the touch
        event, suppressing the generation of any further mouse or click
        events. Alternatively, see the
        <a href="http://wicg.github.io/InputDeviceCapabilities/">InputDeviceCapabilities API</a>
        for a way to detect mouse events that were generated as a result of
        touch events.
      </p>
    </div>
  </section>

  <section>
    <h2>Glossary</h2>

    <dl>
      <dt><dfn>active touch point</dfn></dt>
      <dd>
        A <a>touch point</a> which is currently on the screen and is being
        tracked by the user agent. The touch point becomes active when the
        user agent first dispatches a <a><code>touchstart</code></a> event
        indicating its appearance. It ceases to be active after the user agent
        dispatches a <a><code>touchend</code></a> or
        <a><code>touchcancel</code></a> event indicating that the touch point
        is removed from the surface or no longer tracked.
      </dd>

      <dt><dfn>touch point</dfn></dt>
      <dd>
        The coordinate point at which a pointer (e.g finger or stylus)
        intersects the target surface of an interface. This may apply to a
        finger touching a touch-screen, or an digital pen writing on a piece
        of paper.
      </dd>

      <dt><dfn>canceled event</dfn></dt>
      <dd>
        An event whose default action was prevented by means of
        <code>preventDefault()</code>, returning <code>false</code> in an
        event handler, or other means as defined by [[!DOM-LEVEL-3-EVENTS]]
        and [[!HTML5]].
      </dd>
    </dl>
  </section>

  <section class="appendix informative">
    <h2>Acknowledgements</h2>
    <p>
      Many thanks to the WebKit engineers for developing the model used as a
      basis for this spec, Neil Roberts (SitePen) for his summary of WebKit
      touch events, Peter-Paul Koch (PPK) for his write-ups and suggestions,
      Robin Berjon for developing the
      <a href="http://dev.w3.org/2009/dap/ReSpec.js/documentation.html">ReSpec.js spec authoring tool</a>, and the
      WebEvents WG for their many contributions.
    </p>

    <p>
      Many others have made additional comments as the spec developed, which
      have led to steady improvements. Among them are Matthew Schinckel,
      Andrew Grieve, Cathy Chan, Boris Zbarsky, Patrick H. Lauke, and Simon
      Pieters. If we inadvertently omitted your name, please let me know.
    </p>

    <p>
      The group acknowledges the following contributors to this
      specification's test suite: Matt Brubeck, Olli Pettay, Art Barstow,
      Cathy Chan and Rick Byers.
    </p>
  </section>

  <section class="appendix informative">
    <h2>Changes Since Last Publication</h2>
    <p>
      This is a summary of the major changes made since the
      <a href="http://www.w3.org/TR/touch-events/">
        10 October 2013 Recommendation</a>
      was published.
      <a href="https://github.com/w3c/touch-events/compare/v1...gh-pages">
        Full commit history</a>
      is also available.
    </p>
    <ul>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/125">Reword altitudeAngle/azimuthAngle descriptions in line
          with
          PointerEvents, add illustrations</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/120">Add getModifierState definition</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/303b36e1d188a380f9bc0861b175438e596a34b1">Added force
          attribute to Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/6d222fb7f106273bef847ad1d1d7a23569841954">Added radiusX and
          radiusY attributes to Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/487f6815a9590b72779d4820ff43c2b58d798f92">Added
          rotationAngle attribute to Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/006274ffada14de504f731afdb5ec1581ff327ca">Upgraded
          co-ordinates to double type instead of long</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/df620100e48111cf7a30592f344606f8c8b7fe22">Update touchmove
          behavior on preventDefault</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/54a3d1668c4f727d9c6f6d729b28a036041e301f">Clarify effect of
          canceling touchend event</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/219546b80cd148543a5ece656d81ba3c901d2106">Add constructor
          for TouchEvent and Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/50f51ccacb0d5ad06f9cf6ed44f853d6a3616d10">Added legacy event
          initializer initTouchEvent</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/59">Added support for uncancelable touch events and described
          scroll
          performance implications</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/67">Indicate that all events should be "composed".</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/72">Note about avoiding conditional "touch OR mouse/keyboard"
          event
          handling</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/73">Added TouchEvent's retargeting steps</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/81">Add touchType, altitudeAngle, azimuthAngle (Safari iOS
          10.3
          extensions for stylus)</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/88">Add [Exposed=Window] to Constructor</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/95">Add note to mention UA might adjusting touch target</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/96">Remove Legacy Event Initializers (createTouch and
          createTouchList)</a>
        and the
        <a href="https://github.com/w3c/touch-events/pull/100">note about initTouchEvent / createTouchList</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/111">Conditionally expose legacy touch events API</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/91">Add getModifierState definition to TouchEvent</a>
      </li>
    </ul>
  </section>
</body>
<script src="./custom-script.js" defer></script>

</html>