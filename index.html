<!DOCTYPE html>
<html lang="zh">

<head>
  <title>触摸事件 - 版本 2</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <link href="https://www.w3.org/2008/site/images/favicon.ico" rel="icon">
  <meta name="viewport" content="width=device-width" />
  <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
  <script src="https://www.w3.org/Tools/respec/respec-w3c" defer class="remove"></script>
  <script class="remove">
    var respecConfig = {
      // specification status (e.g. WD, LC, NOTE, etc.). If in doubt use ED.
      specStatus: "UD",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "touch-events",

      // if your specification has a subtitle that goes below the main
      // formal title, define it here
      // subtitle   :  "an excellent document",

      // if you wish the publication date to be other than today, set this
      // publishDate:  "2014-05-29",

      // if the specification's copyright date is a range of years, specify
      // the start date here:
      // copyrightStart: "2005"

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      previousPublishDate: "2013-10-10",
      previousMaturity: "REC",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI: "https://w3c.github.io/touch-events/",
      license: "w3c-software-doc",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2013-02-14",
      // prEnd: "2013-06-06",

      // editors, add as many as you like
      // only "name" is required
      editors: [{
        name: "Doug Schepers",
        url: "http://schepers.cc/",
        company: "W3C",
        companyURL: "http://w3.org/",
      },
      {
        name: "Sangwhan Moon",
        company: "Opera Software ASA",
        companyURL: "http://www.opera.com/",
      },
      {
        name: "Matt Brubeck",
        url: "http://limpet.net/mbrubeck/",
        company: "Mozilla",
        companyURL: "http://www.mozilla.org/",
      },
      {
        name: "Arthur Barstow",
        company: "Invited Expert",
        companyURL: "https://twitter.com/afbarstow",
      },
      {
        name: "Rick Byers",
        url: "http://rbyers.net/",
        company: "Google",
        companyURL: "https://www.google.com/",
      },
      {
        name: "Patrick H. Lauke",
        company: "TetraLogical",
        companyURL: "https://tetralogical.com/",
      },
      ],
      otherLinks: [{
        key: "仓库",
        data: [{
          value: "github项目仓库.",
          href: "https://github.com/w3c/touch-events",
        },
        {
          value: "bug归档.",
          href: "https://github.com/w3c/touch-events/issues",
        },
        {
          value: "提交提示.",
          href: "https://github.com/w3c/touch-events/commits/gh-pages",
        },
        {
          value: "邮件地址.",
          href: "http://lists.w3.org/Archives/Public/public-touchevents/",
        },
        ],
      },
      {
        key: "翻译",
        data: [{
          value: "mangwu.",
          href: "mailto:1185956753@qq.com",
        },
        {
          value: "github项目仓库.",
          href: "https://github.com/mangwu/touch-events-zh",
        },
        ],
      },
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.

      //authors:  [
      //    { name: "Your Name", url: "http://example.org/",
      //      company: "Your Company", companyURL: "http://example.com/" },
      //],

      // Name of the group
      group: "touchevents",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      // wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/45559/status",

      // Enables automatic linking
      xref: ["html", "dom", "infra", "uievents"],
    }
  </script>
  <script id="fixuphook">
      ;
    (function () {
      // Hacky fix-up hook to patch up return types generated by respec.js, as special
      // operations like the ones in specialOps are not officially supported.
      var specialOps = [
        "getter ",
        "setter ",
        "creator ",
        "deleter ",
        "caller ",
        "omittable ",
      ]
      var fixUpCaller = window.setInterval(function () {
        // Check if respec.js is done.
        var respecJS = document.querySelectorAll(".remove")
        if (respecJS.length > 0) return
        else {
          // Performance-wise, this is a stupid idea. For long specs it's probably
          // going to take a *extremely* long time to finish. You have been warned.
          var tags = document.getElementsByTagName("a")

          for (var i = 0; i < tags.length; i++)
            for (var j = 0; j < specialOps.length; j++)
              if (
                tags[i].textContent.indexOf(specialOps[j]) === 0 &&
                tags[i].parentNode.previousSibling.textContent.indexOf(
                  "Return type:"
                ) !== -1
              )
                tags[i].textContent = tags[i].textContent.substring(
                  specialOps[j].length - 1
                )

          // Clean-up script element and interval caller
          var fixUpEl = document.getElementById("fixuphook")
          fixUpEl.parentNode.removeChild(fixUpEl)

          window.clearInterval(fixUpCaller)
        }
      }, 100)
    })()
  </script>

  <style>
    .event {
      font-family: monospace;
      color: #459900;
    }

    pre.idl {
      white-space: pre-wrap;
    }

    .simple th[scope="row"] a {
      color: inherit;
    }
  </style>
  <link rel="stylesheet" href="./override.css" />
</head>

<body>
  <section id="sotd">
    <p>
      通过发布本提案， W3C 希望这个触摸接口提案(Touch Interface Recommendation)
      中的功能性规定不会受到 HTML5 或 Web IDL 更改的影响，
      因为这些规范将继续遵守(proceed to)本提案。工作组已经完成并核准了本规范的
      <a href="http://w3c-test.org/webevents/tests/touch-events-v1/approved/">
        测试套件 </a>，并创建了一份
      <a href="http://www.w3.org/2010/webevents/wiki/TEv1ImplReport">
        实现报告 </a>，显示两个或多个独立的实现是否通过了每种测试。
      此版本的规范包括对<a href="http://www.w3.org/TR/touch-events/">
        第一个版本(Level 1) </a>的修复和改进，并包含了之前作为
      <a href="http://www.w3.org/TR/touch-events-extensions/">
        触摸事件扩展(Touch Event Extensions)</a>发布的特性。
    </p>

    <p>
      (本提案)作为非官方草案出版并不意味着拥有
      <abbr title="World Wide Web Consortium">W3C</abbr>
      及其成员的背书(endorsement)。
    </p>

    <p>
      这是一份草案文件，可能随时被其他文件更新、替换或作废。
      本文档不适合被其它正在编写的规范作为引用。
    </p>

    <p>
      本文档由一个根据
      <a href="https://www.w3.org/Consortium/Patent-Policy-20200915/">
        <abbr title="World Wide Web Consortium">W3C</abbr> 专利政策</a>
      运作的小组编写。<abbr title="World Wide Web Consortium">W3C</abbr>
      保留了一份与该小组可交付成果相关的
      <a href="https://www.w3.org/2004/01/pp-impl/114929/status" rel="disclosure">
        所有可披露专利的公开列表 </a> ;该页面还包括公开一份专利的说明。
      对认为包含
      <a href="https://www.w3.org/Consortium/Patent-Policy-20200915/#def-essential">
        基本权利要求 </a> (Essential Claim(s))的专利有实际了解的个人必须根据
      <a href="https://www.w3.org/Consortium/Patent-Policy-20200915/#sec-Disclosure">
        <abbr title="World Wide Web Consortium">W3C</abbr>专利政策第6节 </a>
      公开信息。
    </p>

    <p>
      本文件受
      <a id="w3c_process_revision" href="https://www.w3.org/2023/Process-20230612/">
        2023 6月12日 <abbr title="World Wide Web Consortium">W3C</abbr>
        处理文档</a> 规范管理。
    </p>
  </section>

  <section id="abstract">
    <p>
      触摸事件规范定义了一组低级别(low-level)事件，
      其表示与触摸敏感平面的一个或多个接触点，以及这些点就触摸表面和在其上的显示
      (例如，触摸屏)或与其相关联(例如，对于没有显示器的绘图板)
      的任何DOM元素而言的变化。它还涉及笔式平板电脑设备，如绘图平板电脑，
      并要考虑到手写笔的功能。
    </p>
  </section>

  <section id="introduction" class="informative">
    <h2>简介</h2>

    <p>
      在提供触摸输入以便让用户使用 Web 应用程序的终端上运行的用户代理，
      通常使用解释执行(interpreted)的鼠标事件使得用户访问交互式的 Web
      应用程序成为可能。然而，
      这些被解释执行的事件是基于物理触摸输入的标准化数据的，
      在提供预期的用户体验方面往往具有局限性。此外，由于鼠标事件的限制
      (既包括系统级的限制，也包括遗留兼容性局限)，无论设备功能如何，
      都不可能处理并发输入(concurrent input)。
    </p>

    <p>
      同时，本地应用程序能够通过提供的系统 APIs 处理这两种情况。
    </p>

    <p>
      触摸事件规范通过声明(specifying)接口以允许 Web 应用程序直接处理触摸事件，
      并为兼容设备(capable devices)提供多个触摸点，从而为该问题提供一种解决方案。
    </p>
  </section>

  <section id="conformance">
    <p>
      除了标记为非规范性的章节外，本规范中的所有创作指南、图表、
      示例和注释都是非规范性。本规范中的其他内容均为规范性内容。
    </p>
    <p>
      本文档中的关键字 <em class="rfc2119">MUST</em> 应按照
      <a href="https://datatracker.ietf.org/doc/html/bcp14">BCP 14</a>
      [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc2119" title="RFC中用于指示需求级别的关键词">RFC2119</a></cite>]
      [<cite><a class="bibref" data-link-type="biblio" href="#bib-rfc8174"
          title="RFC 2119关键字中大写与小写的歧义">RFC8174</a></cite>]
      中的描述进行解释，当且仅当它们以所有字母都是大写出现时，如前所示。
    </p>
    <p>
      本规范定义了适用于单个产品(a single product)的一致性标准:
      实现其包含的接口的用户代理。
    </p>

    <p>WindowProxy 是在 [[!HTML5]] 中定义的。</p>

    <h3 id="webidl-conform">WebIDL 一致性</h3>
    <p>
      本规范中的 IDL 块是符合 WebIDL 规范 [[!WEBIDL]] 定义的 IDL 片段的。
    </p>

    <p>
      符合要求的用户代理也必须是一个
      <a href="http://www.w3.org/TR/WebIDL/#dfn-conforming-ECMAScript-implementation">
        符合 ECMAScript 的实现</a>(本规范中定义的IDL片段的都符合 ECMAScript )，
      但以下情况除外:
    </p>

    <ul>
      <li>
        <a href="http://www.w3.org/TR/WebIDL/#es-attributes">Web IDL的4.4.6节</a>
        要求 IDL 属性作为访问器属性反映(reflected)在接口的原型对象上。与之相反，
        用户代理可以将 IDL 属性反映为实现相关接口的平台对象上的数据属性。
        这些数据属性在获取和设置时必须表现出与调用平台对象上的访问器属性的
        getter 和 setter 时相同的行为。
      </li>
    </ul>
    <p>
      <strong>注意:</strong> 反映 IDL
      属性的两种方式都允许简单地获取和设置平台对象上的属性以使其工作。例如，
      给定一个 <code>Touch</code> 对象 <code>aTouch</code> ，预估(evaluating)
      <code>aTouch.target</code> 为返回 <code>Touch</code> 对象的
      <code>EventTarget</code> 。如果用户代理将 IDL 属性实现为访问器属性，
      那么访问属性将调用返回 <code>EventTarget</code> 的 getter 。
      如果用户代理在平台对象上，以与访问器属性相同的行为，将 IDL
      属性实现为数据属性，则该对象将拥有一个属性名称为 <code>target</code>
      的自有属性，该属性的值为 <code>EventTarget</code> 对象，
      并且访问属性将返回该值。
    </p>
  </section>

  <section>
    <h2 id="touch-interface"><dfn>Touch</dfn> 接口</h2>
    <p>
      此接口描述触摸事件的单个 <a>touch point</a> 。<a><code>Touch</code></a>
      对象是不可变的(immutable); 创建后，其属性不得更改。
    </p>
    <pre class="idl">
enum TouchType {
    "direct",
    "stylus"
};

dictionary TouchInit {
    required long        identifier;
    required EventTarget target;
             double      clientX = 0;
             double      clientY = 0;
             double      screenX = 0;
             double      screenY = 0;
             double      pageX = 0;
             double      pageY = 0;
             float       radiusX = 0;
             float       radiusY = 0;
             float       rotationAngle = 0;
             float       force = 0;
             double      altitudeAngle = 0;
             double      azimuthAngle = 0;
             TouchType   touchType = "direct";
};

[Exposed=Window]
interface Touch {
    constructor(TouchInit touchInitDict);
    readonly        attribute long        identifier;
    readonly        attribute EventTarget target;
    readonly        attribute double      screenX;
    readonly        attribute double      screenY;
    readonly        attribute double      clientX;
    readonly        attribute double      clientY;
    readonly        attribute double      pageX;
    readonly        attribute double      pageY;
    readonly        attribute float       radiusX;
    readonly        attribute float       radiusY;
    readonly        attribute float       rotationAngle;
    readonly        attribute float       force;
    readonly        attribute float       altitudeAngle;
    readonly        attribute float       azimuthAngle;
    readonly        attribute TouchType   touchType;
};
      </pre>
    <dl data-dfn-for="Touch" data-link-for="Touch">
      <dt><dfn>identifier</dfn></dt>
      <dd>
        <p>每个 <a>touch point</a> 的标识符数字。</p>
        <p>
          当一个触摸点活跃时，必须为其分配一个不同于其他任何
          <a>active touch point</a> 的 <a>identifier</a> 。
          当触摸点保持活跃时，所有引用它的事件都必须为它分配相同的
          <a>identifier</a> 。
        </p>
      </dd>

      <dt><dfn>target</dfn></dt>
      <dd>
        <p>
          <a>touch point</a> 所在的 <code>EventTarget</code> ，
          从它第一次放置在触摸平面上时开始记录，即使 <a>touch point</a>
          已经移动到该元素(事件对象)的交互区域之外。
        </p>
        <div class="note">
          一些实现会变更(alter)目标元素以校正粗略输入(coarse input)的不精确性。
          因此，目标元素不一定是直接位于事件坐标处的元素。用于针对/消除
          (target/disambiguate)粗略输入的歧义的方法超出了本规范的讨论范围。
        </div>
      </dd>

      <dt><dfn>screenX</dfn></dt>
      <dd>
        <p>
          触摸点相对于屏幕的水平坐标(以像素为单位)
        </p>
      </dd>
      <dt><dfn>screenY</dfn></dt>
      <dd>
        <p>
          触摸点相对于屏幕的垂直坐标(以像素为单位)
        </p>
      </dd>

      <dt><dfn>clientX</dfn></dt>
      <dd>
        <p>
          触摸点相对于视口的水平坐标(以像素为单位)，不包括任何的滚动偏移量
        </p>
      </dd>
      <dt><dfn>clientY</dfn></dt>
      <dd>
        <p>
          触摸点相对于视口的垂直坐标(以像素为单位)，不包括任何的滚动偏移量
        </p>
      </dd>

      <dt><dfn>pageX</dfn></dt>
      <dd>
        <p>
          触摸点相对于视口的水平坐标(以像素为单位)，包括任何存在的滚动偏移量
        </p>
      </dd>
      <dt><dfn>pageY</dfn></dt>
      <dd>
        <p>
          触摸点相对于视口的垂直坐标(以像素为单位)，包括任何存在的滚动偏移量
        </p>
      </dd>
      <dt><dfn>radiusX</dfn></dt>
      <dd>
        <p>
          一个椭圆的水平轴半径，该椭圆是沿着 rotationAngle
          指示的轴最紧密地包围触摸区域(例如手指、触笔)构成的最小椭圆，
          属性单位为与 screenX 相同比例的 CSS 像素(由[[!CSS-VALUES]]定义);
          如果值未知，则为 <code>0</code> 。该值不能为负数。
        </p>
      </dd>
      <dt><dfn>radiusY</dfn></dt>
      <dd>
        <p>
          一个椭圆的垂直轴半径，该椭圆是沿着 rotationAngle
          指示的轴最紧密地包围触摸区域(例如手指、触笔)构成的最小椭圆，
          属性单位为与 screenX 相同比例的 CSS 像素(由[[!CSS-VALUES]]定义);
          如果值未知，则为 <code>0</code> 。该值不能为负数。
        </p>
      </dd>
      <dt><dfn>rotationAngle</dfn></dt>
      <dd>
        <p>
          由 radiusX 和 radiusY 描述的椭圆绕其中心顺时针旋转的角度(以度为单位);
          如果值未知，则为 <code>0</code> 。该值必须大于或等于 <code>0</code>
          且小于 <code>90</code> 。
        </p>

        <p>
          如果由 radiusX 和 radiusY 描述的椭圆是圆形的，则 rotationAngle
          的值不会影响(触摸点)。在这种情况下，用户代理可以使用 <code>0</code>
          作为值，也可以使用允许范围内的任何其他值。(例如，
          用户代理可以使用上一次触摸事件的 rotationAngle 值，以避免突然的变化。)
        </p>

        <div class="note custom-note">
          由 radiusX 和 radiusY 描述的正方向的椭圆，通过顺时针旋转这个角度后，
          能最精确地覆盖住用户和触摸平面的接触面的角度。
          这个值可能从 0 到 90。这三个值一起描述了用户和触摸平面的接触面的形状的大小。
        </div>
      </dd>
      <dt><dfn>force</dfn></dt>
      <dd>
        <p>
          施加的压力的相对值，在 <code>0</code> 到 <code>1</code> 的范围内，其中
          <code>0</code> 是无压力， <code>1</code>
          是触摸设备能够感测的最高压力水平; 如果值未知，则为 <code>0</code> 。
          在已知的力的环境中，由 force
          属性表示的绝对压力和压力级别的灵敏度可能会稍有调整。
        </p>
      </dd>
      <dt><dfn>altitudeAngle</dfn></dt>
      <dd>
        <p>
          传感器(例如电子笔/手写笔)的俯仰角(以弧度为单位)，范围为 [0，π/2] —
          其中 0 表示(笔)平行于触摸平面(X-Y平面)， π/2 表示(笔)垂直于触摸平面。
          对于不报告或不支持倾斜度(tilt)或角度的硬件和平台，该值
          <span class="zh-upper">必须</span> 为 0 。
        </p>

        <div class="note">
          此处为 <code>altitudeAngle</code> 属性定义的默认值为 0 。
          这与 <a href="https://w3c.github.io/pointerevents/">
            指针事件 - 版本 3 </a> [[POINTEREVENTS]] 规范对
          <code>altitudeAngle</code> 属性的定义不同，后者属性的默认值为 π/2 ，
          即将传感器(默认)定位为垂直于平面。
        </div>

        <figure id="figure_altitudeAngle">
          <img src="images/altitudeAngle.png" alt="altitudeAngle属性解释图例" />
          <figcaption>
            <code>altitudeAngle</code> 属性值为 π/4 (相对于 X-Y 平面 45 度)的示例。
          </figcaption>
        </figure>
      </dd>
      <dt><dfn>azimuthAngle</dfn></dt>
      <dd>
        <p>
          表示传感器(transducer，例如电子笔/手写笔)的方位角(以弧度为单位)，
          范围为 [0，2π] — 其中 0 值表示: 一个传感器，其笔帽指向 X-Y 平面上 X
          值增加的方向(如果向下看，则指向 "3点钟" 方向)，顺时针方向时，
          值逐渐增加( "6点钟" 处值为的 π/2 ， "9点钟" 处值为 π ， "12点钟"
          处值为 3π/2 )。当传感器完全垂直于表面(俯仰角，也就是
          <code>altitudeAngle</code> 为 π/2 )时，该值 <span class="zh-upper">
            必须</span> 为 0 。对于不报告倾斜或角度的硬件和平台，该值
          <span class="zh-upper">必须</span> 为 0 。
        </p>
        <figure id="figure_azimuthAngle">
          <img src="images/azimuthAngle.png" alt="azimuthAngle explanation diagram" />
          <figcaption>
            <code>azimuthAngle</code> 属性值为 π/6 ("4 点钟方向")的示例。
          </figcaption>
        </figure>
      </dd>
      <dt><dfn>touchType</dfn></dt>
      <dd>
        <p>用于触发触摸的设备类型。</p>
      </dd>
    </dl>
    <dl>
      <dt><dfn>TouchType</dfn></dt>
      <dd>
        <p>
          枚举类型，表示触摸输入可能的不同类型。
        </p>
      </dd>
    </dl>
    <dl data-dfn-for="TouchType" data-link-for="TouchType">
      <dt><dfn>direct</dfn></dt>
      <dd>
        <p>
          TouchType 枚举的一种触摸输入类型，字符串，表示手指在屏幕上的直接触摸。
        </p>
      </dd>
      <dt><dfn>stylus</dfn></dt>
      <dd>
        <p>
          TouchType 枚举的一种触摸输入类型，字符串，表示手写笔或电子笔设备的触摸。
        </p>
      </dd>
    </dl>
  </section>

  <section>
    <h2 id="touchlist-interface"><dfn>TouchList</dfn> 接口</h2>
    <p>
      该接口定义了触摸事件的各个(individual)接触点的列表。
      <a><code>TouchList</code></a> 对象是不可变的(immutable); 创建后，
      其内容不得更改。
    </p>
    <p>
      一个 <code>TouchList</code> 对象 <em>支持的属性索引</em> ([[!WEBIDL]])
      是 0 到比列表长度小 1 之间的数字。
    </p>
    <pre class="idl">
[Exposed=Window]
interface TouchList {
    readonly        attribute unsigned long length;
    getter Touch? item (unsigned long index);
};
      </pre>
    <dl data-dfn-for="TouchList" data-link-for="TouchList">
      <dt><dfn>length</dfn></dt>
      <dd>
        <p>
          返回列表中 <a><code>Touch</code></a> 对象的数量
        </p>
      </dd>
      <dt><dfn>item</dfn></dt>
      <dd>
        <p>
          返回列表中指定索引处的 <a><code>Touch</code></a> 对象，
          如果传递的索引值不小于列表长度，则返回 <code>null</code> 。
        </p>
      </dd>
    </dl>
  </section>

  <section>
    <h2 id="touchevent-interface"><dfn>TouchEvent</dfn> 接口</h2>
    <p>
      此接口定义了 <a><code>touchstart</code></a> 、
      <a><code>touchend</code></a> 、 <a><code>touchmove</code></a> 和
      <a><code>touchcancel</code></a> 事件类型。 <a><code>TouchEvent</code></a>
      对象是不可变的(immutable); 创建并初始化一个后，其属性不得更改。
      <code>TouchEvent</code> 继承自 [[!DOM-LEVEL-3-EVENTS]] 中定义的
      <code>UIEvent</code> 接口。
    </p>
    <p>
      <code>TouchEvent</code> 接口的构造函数使用 <dfn>TouchEventInit</dfn>
      字典提供的一种机制(mechanism)，来构造不可信(合成)的触摸事件。
      它继承自 [[!DOM-LEVEL-3-EVENTS]] 中定义的 <code>EventModifierInit</code>
      字典。 [[!DOM4]] 中定义了构建事件的步骤。
      有关演示如何触发不可信的触摸事件的示例代码，请参阅该
      <a href="#firing-a-synthetic-touchevent-from-script" title="examples">
        示例
      </a> 。
    </p>
    <pre class="idl">
dictionary TouchEventInit : EventModifierInit {
             sequence&lt;Touch&gt; touches = [];
             sequence&lt;Touch&gt; targetTouches = [];
             sequence&lt;Touch&gt; changedTouches = [];
};

[Exposed=Window]
interface TouchEvent : UIEvent {
    constructor(DOMString type, optional TouchEventInit eventInitDict = {});
    readonly        attribute TouchList touches;
    readonly        attribute TouchList targetTouches;
    readonly        attribute TouchList changedTouches;
    readonly        attribute boolean   altKey;
    readonly        attribute boolean   metaKey;
    readonly        attribute boolean   ctrlKey;
    readonly        attribute boolean   shiftKey;
    getter boolean getModifierState (DOMString keyArg);
};
      </pre>
    <dl data-dfn-for="TouchEvent" data-link-for="TouchEvent">
      <dt><dfn>touches</dfn></dt>
      <dd>
        <p>
          表示当前触摸平面上的每个接触点的 <a><code>Touch</code></a> 对象列表。
        </p>
        <div class="note custom-note">
          一个 <a><code>TouchList</code></a> ，
          其会列出所有当前在与触摸表面接触的 <a><code>Touch</code></a> 对象，
          不管触摸点是否已经改变或其目标元素是在处于
          <a><code>touchstart</code></a> 阶段。
        </div>
      </dd>
      <dt><dfn>targetTouches</dfn></dt>
      <dd>
        <p>
          每个接触点的 <a><code>Touch</code></a> 对象列表，
          这些接触点正在接触触摸平面 <em>并且</em>
          是从当前事件目标的元素上开始的。
        </p>
        <div class="note custom-note">
          所谓 "从当前事件目标的元素上开始的" 的意思就是: 这些接触点触发的
          <code>touchstart</code> 事件发生在与当前触发的触摸事件相同的目标元素内。
        </div>
      </dd>
      <dt><dfn>changedTouches</dfn></dt>
      <dd>
        <p>
          为事件做出贡献(contributed)的每个接触点的 <a><code>Touch</code></a>
          对象列表。
        </p>
        <p>
          对于 <a><code>touchstart</code></a> 事件，(该属性的值)
          必须是与当前事件一起刚刚激活(active)的触摸点的列表。
          对于 <a><code>touchmove</code></a> 事件，(该属性的值)
          必须是自上次事件发生以来产生移动的触摸点的列表。对于
          <a><code>touchend</code></a> 和 <a><code>touchcancel</code></a> 事件，
          (该属性的值)必须是刚刚从触摸平面移开的触摸点的列表，
          这些触摸点附带最后移除之前已知坐标信息。
        </p>
      </dd>

      <dt><dfn>altKey</dfn></dt>
      <dd>
        <p>
          如果 alt (Alternate)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code>
        </p>
      </dd>
      <dt><dfn>metaKey</dfn></dt>
      <dd>
        <p>
          如果 meta (Meta)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code> 。在某些平台上，
          此属性可能映射到名称不同的修饰符按键。
        </p>
      </dd>
      <dt><dfn>ctrlKey</dfn></dt>
      <dd>
        <p>
          如果 ctrl (Control)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code>
        </p>
      </dd>
      <dt><dfn>shiftKey</dfn></dt>
      <dd>
        <p>
          如果 shift (Shift)修饰符键被激活，则为 <code>true</code> ; 否则为
          <code>false</code>
        </p>
      </dd>
      <dt><dfn>getModifierState</dfn>(keyArg)</dt>
      <dd>
        <p>
          使用键值查询修饰符按键的状态。
          如果它是修饰符按键并且该修饰符按键处于激活状态，则返回
          <code>true</code> ，否则返回 <code>false</code> 。
        </p>
        <div class="note custom-note">
          关于修饰符按键(key modifier)以及键值，可以参阅 [[UIEVENTS]] 和
          [[UIEvents-Key]] 。
        </div>

      </dd>
    </dl>

    <section class="informative">
      <h2 id="touchevent-implementer-s-note">TouchEvent 接口实现者的注释</h2>
      <div class="note">
        <p>
          用户代理应确保来自给定 <a><code>TouchEvent</code></a> 中的所有可用
          <a><code>Touch</code></a> 对象都与 <a><code>TouchEvent</code></a>
          被派发到的同一文档相关联。为了实现这一点，用户代理应保留当前
          <em>触摸活动(touch-active)</em> 文档的概念(notion)。在第一次触摸时，
          它(当前 <em>触摸活动(touch-active)</em> 文档)
          被设置为创建触摸的目标文档。当释放完所有活跃的触摸点后，
          <em>触摸活动(touch-active)</em> 文档将被清除。
          所有 <a><code>TouchEvent</code></a> 都被派发到当前
          <em>触摸活动(touch-active)</em> 文档，并且它(触摸事件)包含的每个
          <a><code>Touch</code></a> 对象仅引用该文档中的 DOM 元素(和坐标信息)。
          如果触摸完全在当前 <em>触摸活动(touch-active)</em> 文档之外开始，
          则会完全忽略该触摸。
        </p>
      </div>
    </section>

    <section class="informative">
      <h2 id="usage-examples">用例</h2>

      <p>
        下面的示例演示了 <a><code>TouchEvent</code></a> 中定义的不同
        <a><code>TouchList</code></a> 成员之间的关系。
      </p>

      <section>
        <h3 id="touchevent-touches-targettouches">
          一个 <a><code>TouchEvent</code></a> 的 <code>touches</code> 和
          <code>targetTouches</code>
        </h3>

        <p>
          此示例演示了<a><code>TouchEvent</code></a> 接口中定义的
          <code>touches</code> 和 <code>targetTouches</code> 成员之间的功能
          (utility)和关系。以下代码将根据在可触摸元素(touchable element)
          和文档上的触摸点数量生成不同的输出:
        </p>

        <pre class="example">
&lt;div id='touchable'&gt;这个元素是可触摸的。&lt;/div&gt;

&lt;script&gt;
document.getElementById('touchable').addEventListener('touchstart', function(ev) {

    if (ev.touches.item(0) == ev.targetTouches.item(0))
    {
        /**
         * 如果在触摸平面上的第一次触摸的目标元素就是 "可触摸" 元素，
         * 则应执行以下代码。由于 targetTouches 是覆盖整个触摸平面的
         * touches 的子集，因此 TouchEvent.touches >= TouchEvents.targetTouches
         * 始终为 true 。
         */

        document.write('Hello Touch Events!');
    }

    if (ev.touches.length == ev.targetTouches.length)
    {
        /**
         * 如果所有活跃触摸点都在 "可触摸" 元素上，
         * 则长度属性应相同。
         */

        document.write('All points are on target element')
    }

    if (ev.touches.length > 1)
    {
        /**
         * 在单点触摸输入设备上，触摸平面上只能有一个接触点，
         * 因此只有当终端支持多点触摸时，
         * 才能执行以下代码。
         */

        document.write('Hello Multiple Touch!');
    }

}, false);
&lt;/script&gt;
</pre>
      </section>

      <section>
        <h3 id="changedtouches-of-a-touchevent">
          一个 <a><code>TouchEvent</code></a> 的 <code>changedTouches</code>
        </h3>

        <p>
          此示例演示了 <code>changedTouches</code> 的实用功能(utility)及其它与
          <a><code>TouchEvent</code></a> 接口中的其他
          <a><code>TouchList</code></a> 成员的关系。
          该代码是一个，每当从定义好的可触摸元素中移除触摸点时就会触发的示例:
        </p>

        <pre class="example">
&lt;div id='touchable'&gt;This element is touchable.&lt;/div&gt;

&lt;script&gt;
document.getElementById('touchable').addEventListener('touchend', function(ev) {
    /**
     * 当三个触摸点在触摸平面上时的示例输出如下，
     * 其中两个在 "可触摸" 元素上，
     * 另一个点从 "可触摸的" 元素中的触摸表面抬起(移除):
     *
     * Touch points removed: 1
     * Touch points left on element: 1
     * Touch points left on document: 2
     */

    document.write('Touch points removed: ' + ev.changedTouches.length);
    document.write('Touch points left on element: ' + ev.targetTouches.length);
    document.write('Touch points left on document: ' + ev.touches.length);

}, false);
&lt;/script&gt;
</pre>
      </section>

      <section>
        <h3 id="firing-a-synthetic-touchevent-from-script">
          触发来自于脚本合成的 <a><code>TouchEvent</code></a>
        </h3>

        <p>
          此示例演示如何创建和触发来自于脚本的 <a><code>TouchEvent</code></a> 。
        </p>

        <pre class="example">

if (Touch.length &lt; 1 || TouchEvent.length &lt; 1)
  throw "TouchEvent constructors not supported";

var touch = new Touch({
    identifier: 42,
    target: document.body,
    clientX: 200,
    clientY: 200,
    screenX: 300,
    screenY: 300,
    pageX: 200,
    pageY: 200,
    radiusX: 5,
    radiusY: 5
});

var touchEvent = new TouchEvent("touchstart", {
    cancelable: true,
    bubbles: true,
    composed: true,
    touches: [touch],
    targetTouches: [touch],
    changedTouches: [touch]
});

document.body.dispatchEvent(touchEvent);
</pre>
      </section>
    </section>

    <section class="informative">
      <h2 id="list-of-touchevent-types">
        <a><code>TouchEvent</code></a> 事件类型列表
      </h2>

      <p>
        下表提供了本规范中定义的 <a><code>TouchEvent</code></a> 事件类型的总结。
        所有事件都应完成(accomplish)冒泡阶段。所有事件均应由 [[WHATWG-DOM]]
        事件构成(be composed)。
      </p>

      <!--
          // FIXME: As of the time of writing, respec.js doesn't have support for
          // tables like this - we're just piggybacking on a existing class, with
          // raw markup as a quick and dirty workaround.
          -->

      <table class="simple" id="table-event-summary">
        <thead>
          <tr>
            <th>事件类型</th>
            <th>同步 / 异步</th>
            <th>冒泡阶段</th>
            <th>能否从Shadow
              DOM冒泡传递(composed)</th>
            <th>可信近端事件目标对象类型</th>
            <th>接口</th>
            <th>可取消默认行为</th>
            <th>默认行为</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row">
              <a><code>touchstart</code></a>
            </th>
            <td>同步</td>
            <td>能</td>
            <td>能</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td><a href="#cancelability">多种(Varies)</a></td>
            <td>未定义</td>
          </tr>
          <tr>
            <th scope="row">
              <a><code>touchend</code></a>
            </th>
            <td>同步</td>
            <td>能</td>
            <td>能</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td><a href="#cancelability">多种(Varies)</a></td>
            <td>
              多种(Varies): 用户代理可以派发
              <a href="#mouse-events">鼠标和点击事件</a>
            </td>
          </tr>
          <tr>
            <th scope="row">
              <a><code>touchmove</code></a>
            </th>
            <td>同步</td>
            <td>能</td>
            <td>能</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td><a href="#cancelability">多种(Varies)</a></td>
            <td>未定义</td>
          </tr>
          <tr>
            <th scope="row">
              <a><code>touchcancel</code></a>
            </th>
            <td>同步</td>
            <td>能</td>
            <td>能</td>
            <td><code>Document</code>, <code>Element</code></td>
            <td>
              <a><code>TouchEvent</code></a>
            </td>
            <td>不可</td>
            <td>没有</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h3 id="cancelability">触摸事件的可取消性(Cancelability)</h3>
      <p>
        <a href="#dfn-canceled-event">取消</a> (调用
        <code>preventDefault</code> )触摸事件可以阻止或中断(interrupt)滚动
        (滚动可能与脚本执行并行发生)。为了获得最大的滚动性能，
        用户代理可能不会等待每个与滚动相关联的触摸事件被处理完毕
        (检阅滚轮事件是否被取消)才派发事件。在这种情况下，
        用户代理应该生成 <code>cancelable</code> 属性为 <code>false</code>
        的触摸事件，表明 <code>preventDefault</code> 不能用于阻止或中断滚动。
        否则 <code>cancelable</code> 属性将为 <code>true</code> 。
      </p>
      <p>
        特别是，当用户代理发现事件
        <a href="https://dom.spec.whatwg.org/#observing-event-listeners">
          没有非被动监听器(non-passive listeners)</a> 时，它应该只生成不可取消
        (uncancelable)的触摸事件。
      </p>

      <div class="note custom-note">
        在 [[DOM]] 中的 <code>EventTarget</code> 接口中介绍了
        <code>addEventListener()</code> 方法的第三个参数，它的字典定义有一个
        <code>passive</code> 属性，表示事件监听器是否永远不会调用
        <code>preventDefault</code> ，非被动监听器(non-passive listeners)就是
        <code>passive</code> 设置为 <code>false</code> (默认值)的事件监听器，
        它表示事件可被取消; 再理解上面的话，特意设置 <code>passive</code> 属性为
        <code>true</code> ，那么实现只会生成不可取消的触摸事件。
      </div>
    </section>

    <section>
      <h3 id="event-touchstart">
        <dfn class="event"><code>touchstart</code></dfn> 事件
      </h3>
      <p>
        当用户放置 <a>touch point</a> 在触摸表面上时，
        用户代理必须派发此事件类型的事件以示意(indicate)。
      </p>

      <p>
        此事件的事件目标必须是 <code>Element</code> 。如果触摸点在一个框架
        (frame — &lt;iframe&gt; 表示嵌套的浏览上下文)内，
        则应将事件派发到该框架的在子浏览上下文中的元素。
      </p>

      <p>
        如果此事件被 <a href="#dfn-canceled-event">取消</a> ，
        则应阻止由与同一 <a>active touch point</a>
        关联的任何触摸事件引起的任何默认操作，包括鼠标事件或滚动。
      </p>
    </section>

    <section data-link-for="TouchEvent">
      <h3 id="event-touchend">
        <dfn class="event"><code>touchend</code></dfn> 事件
      </h3>
      <p>
        当用户从触摸平面移除一个 <a>touch point</a> 时，
        用户代理必须派发此事件类型的事件以示意(indicate)，
        除此之外，触摸点物理离开触摸平面的情况(例如被拖离屏幕)也会触发此事件。
      </p>

      <p>
        该事件的事件目标必须是 <a>touch point</a>
        从第一次放置在触摸平面上时开始记录的同一 <code>Element</code> ，
        即使 <a>touch point</a> 已经移动到目标元素的交互区域之外。
      </p>

      <p>
        被移除的一个或多个 <a>touch point</a> 必须包含在
        <a><code>TouchEvent</code></a> 的 <a><code>changedTouches</code></a>
        属性中，而不能包含在 <a><code>touches</code></a> 和
        <a><code>targetTouches</code></a> 属性中。
      </p>

      <p>
        如果此事件被 <a href="#dfn-canceled-event">取消</a> ，
        则包括此事件的任何触摸事件序列都不得被
        <a href="#click-events">解释为单击</a> 。
      </p>
    </section>

    <section>
      <h3 id="event-touchmove">
        <dfn class="event"><code>touchmove</code></dfn> 事件
      </h3>
      <p>
        当前用户沿着触摸平面移动 <a>touch point</a> 时，
        用户代理必须派发此事件类型的事件以示意(indicate)。
      </p>

      <p>
        该事件的事件目标必须是 <a>touch point</a>
        从第一次放置在触摸平面上时开始记录的同一 <code>Element</code> ，
        即使 <a>touch point</a> 已经移动到目标元素的交互区域之外。
      </p>

      <p>
        请注意，用户代理发送 <a><code>touchmove</code></a>
        事件的速率是由实现定义的(implementation-defined)，
        并且(速率大小)可能取决于硬件功能和其他实现细节。
      </p>

      <p>
        用户代理应该阻止(suppress)由任何 <a><code>touchmove</code></a>
        事件引起的默认行为，直到与同一 <a>active touch point</a>
        相关联的至少一个 <a><code>touchmove</code></a> 事件没有被
        <a href="#dfn-canceled-event">取消</a> 为止。在与同一
        <a>active touch point</a> 相关联的 <a><code>touchmove</code></a>
        事件至少一个未被 <a href="#dfn-canceled-event">取消</a> 之后，
        是否阻止(suppress) <a><code>touchmove</code></a>
        事件的默认行为取决于实现。
      </p>
    </section>

    <section data-link-for="TouchEvent">
      <h3 id="event-touchcancel">
        <dfn class="event"><code>touchcancel</code></dfn> 事件
      </h3>
      <p>
        当一个触摸点以实现决定(implementation-specific)的方式被中断(disrupted)
        时，用户代理必须派发该事件类型的事件以示意(indicate)，
        中断方式有如源自用户代理取消触摸的同步事件或行为，
        或者触摸点离开文档窗口进入能够处理用户交互的非文档(non-document)区域
        (非文档区域指用户代理的本地用户界面，或由插件管理的文档区域等)。
        当用户在触摸平面上放置的 <a>touch point</a>
        多于设备或实现为存储触摸点配置的数量时，
        用户代理也可以派发该事件类型的事件，在这种情况下，应该移除
        <a><code>TouchList</code></a> 中最早的 <a><code>Touch</code></a> 对象。
      </p>

      <p>
        该事件的事件目标必须是 <a>touch point</a>
        从第一次放置在触摸平面上时开始记录的同一 <code>Element</code> ，
        即使 <a>touch point</a> 已经移动到目标元素的交互区域之外。
      </p>

      <p>
        被移除的一个或多个 <a>touch point</a> 必须包含在
        <a><code>TouchEvent</code></a> 的 <a><code>changedTouches</code></a>
        属性中，而不能包含在 <a><code>touches</code></a> 和
        <a><code>targetTouches</code></a> 属性内。
      </p>
    </section>
  </section>

  <section>
    <h2 id="retargeting">重新定位目标(Retargeting)</h2>
    <p>
      以下部分介绍了 [[!WHATWG-DOM]] 中定义的
      <a href="https://dom.spec.whatwg.org/#event-retargeting-steps">
        重新定位目标的步骤</a> 。
    </p>

    <p>
      <code>Touch</code> 对象具有关联的 <dfn>unadjustedTarget</dfn>
      (未重定向的目标，是 <code>null</code> 或 <code>EventTarget</code> )。
      除非另有说明，否则就是 <code>null</code> 。
    </p>

    <p>
      <code>TouchEvent</code> 的
      <a href="https://dom.spec.whatwg.org/#event-retargeting-steps">
        重新定位目标的步骤</a> ，给定一个 <var>touchEvent</var> ，
      必须运行如下步骤:
    </p>
    <ol>
      <li>
        <p>
          对于 <var>touchEvent</var> 对象的 <code>touches</code> 、
          <code>targetTouches</code> 和 <code>changedTouches</code> 成员中的每个
          <a><code>Touch</code></a> 对象:
        </p>
        <ol>
          <li>
            如果 <var>touch</var> 的 <a><code>unadjustedTarget</code></a> 为空，
            则将 <var>touch</var> 的 <a><code>unadjustedTarget</code></a> 设置为
            <var>touch</var> 的 <code>target</code> 。
          </li>
          <li>
            将 <var>touch</var> 的 <code>target</code> 设置为针对
            <var>touchEvent</var> 的目标调用
            <a href="https://dom.spec.whatwg.org/#retarget">重定目标</a> 的
            <var>touch</var> 的 <a><code>unadjustedTarget</code></a> 的结果。
          </li>
        </ol>
      </li>
    </ol>
  </section>

  <section>
    <h2 id="conditionally-exposing-legacy-touch-event-apis">有条件地暴露遗留触摸事件</h2>
    <p>
      用户代理有一个关联的布尔类型 <dfn data-export="暴露遗留触摸事件API">
        expose legacy touch event APIs</dfn> (暴露遗留触摸事件 APIs )，其值由
      <a href="https://infra.spec.whatwg.org/#implementation-defined">
        实现定义</a> 。
    </p>

    <p class="note">
      现有的网络内容通常使用这些 APIs 的存在作为用户代理是否支持触摸的
      (touch-enabled) "移动" 设备的信号，因此在非移动设备上暴露这些 APIs ，
      即使它们(用户代理)支持触摸，也可能导致此类网络内容的未达到最佳标准的
      (suboptimal)用户体验。
    </p>
  </section>

  <section>
    <h2 id="extensions-to-the-globaleventhandlers-mixin">
      <code>GlobalEventHandlers</code> 混入(mixin)的扩展
    </h2>
    <p>
      以下部分描述了在 [[!HTML5]] 中定义的现有
      <dfn data-cite="HTML5#globaleventhandlers">GlobalEventHandlers</dfn> 混入
      (mixin)的扩展，以便于事件处理程序注册。对于
      <a href="#dfn-expose-legacy-touch-event-apis">暴露遗留触摸事件 APIs</a>
      为 <code>false</code> 的用户代理，不得实现此混入(mixin)。
    </p>
    <pre class="idl">
partial interface mixin GlobalEventHandlers {
                    attribute EventHandler ontouchstart;
                    attribute EventHandler ontouchend;
                    attribute EventHandler ontouchmove;
                    attribute EventHandler ontouchcancel;
};
      </pre>
    <dl data-dfn-for="GlobalEventHandlers" data-link-for="GlobalEventHandlers">
      <dt><dfn>ontouchstart</dfn></dt>
      <dd>
        <p>
          <code>touchstart</code> 事件类型的事件处理程序 IDL 属性
          (请参见 [[!HTML5]] )。
        </p>
      </dd>
      <dt><dfn>ontouchend</dfn></dt>
      <dd>
        <p>
          <code>touchend</code> 事件类型的事件处理程序 IDL 属性
          (请参见 [[!HTML5]] )。
        </p>
      </dd>
      <dt><dfn>ontouchmove</dfn></dt>
      <dd>
        <p>
          <code>touchmove</code> 事件类型的事件处理程序 IDL 属性
          (请参见 [[!HTML5]] )。
        </p>
      </dd>
      <dt><dfn>ontouchcancel</dfn></dt>
      <dd>
        <p>
          <code>touchcancel</code> 事件类型的事件处理程序 IDL 属性
          (请参见 [[!HTML5]] )。
        </p>
      </dd>
    </dl>
  </section>

  <section id="mouse-events">
    <h2>与鼠标事件和 <code>click</code> 的交互(Interaction)</h2>
    <p>
      用户代理可以通过派发触摸事件和(为了与不是为触摸而设计的 Web 内容兼容)
      鼠标事件 [[!DOM-LEVEL-2-EVENTS]] 响应相同的用户输入。
      如果用户代理同时派发触摸事件和鼠标事件以响应一个用户的单个操作，
      则必须为该操作触发的任何鼠标事件类型之前派发
      <a><code>touchstart</code></a> 事件类型的事件。如果
      <a href="#dfn-canceled-event">取消</a> 了 <a><code>touchstart</code></a>
      、 <a><code>touchmove</code></a> 或 <a><code>touchend</code></a> ，
      用户代理不应派发任何可能因此也导致阻止鼠标事件的触摸事件
      (部分触摸事件的取消会导致鼠标事件的取消，这属于间接结果——
      consequential result)。
    </p>

    <p class="note">
      如果一个 Web 应用程序可以处理触摸事件，它可以
      <a href="#dfn-canceled-event">取消</a> 这些事件，
      并且用户代理不需要派发相应的鼠标事件。
      如果 Web 应用程序不是专门为触摸输入设备编写的，
      它将对随后的鼠标事件做出反应。
    </p>

    <p class="note">
      用户代理通常只针对单指激活手势(如点击和长按)派发鼠标和点击事件。
      涉及触摸点移动或多触摸(multi-touch)交互的手势 – 具有两个或多个
      <a href="#dfn-active-touch-point">活跃触摸点</a> – 通常只会产生触摸事件。
    </p>

    <p id="click-events">
      如果用户代理将一系列触摸事件解释为轻触(tap)手势，
      那么它应该在响应触摸输入的 <a><code>touchend</code></a> 事件的位置派发
      <code>mousemove</code> 、 <code>mousedown</code> 、 <code>mouseup</code>
      和 <code>click</code>事件(按顺序)。
      如果文档的内容在触摸事件的处理期间已经改变，
      则用户代理可以将鼠标事件派发到与触摸事件 <strong>不同</strong> 的目标上。
    </p>

    <p>
      任何进一步的触摸和鼠标事件的默认行为和顺序都是由实现定义的，
      除非在别处详细指定。
    </p>

    <div class="note">
      <p>
        元素的激活(例如，在一些实现中，轻触)通常会产生以下事件序列
        (尽管取决于特定的用户代理行为，可能会略有不同):
      </p>
      <ol data-class="note-list">
        <li><code>touchstart</code></li>
        <li>
          零个或多个 <code>touchmove</code> 事件，具体取决于手指的移动
        </li>
        <li><code>touchend</code></li>
        <li>
          <code>mousemove</code>
          <small>(与遗留的鼠标特定的代码进行兼容)</small>
        </li>
        <li><code>mousedown</code></li>
        <li><code>mouseup</code></li>
        <li><code>click</code></li>
      </ol>
      <p>
        但是，如果在该交互过程中 <a href="#dfn-canceled-event">取消</a> 了
        <code>touchstart</code> 、 <code>touchmove</code> 或
        <code>touchend</code> 事件，则不会触发鼠标或单击事件，
        由此产生的事件序列仅为:
      </p>
      <ol data-class="note-list">
        <li><code>touchstart</code></li>
        <li>
          零个或多个 <code>touchmove</code> 事件，具体取决于手指的移动
        </li>
        <li><code>touchend</code></li>
      </ol>
    </div>

    <div class="note">
      <p>
        即使用户代理支持 Touch Events ，这也不一定意味着触摸屏(touchscreen)
        是用户唯一可以用用的输入机制。特别是在支持触摸(touch-enabled)
        的笔记本电脑或附带有配对的外部输入设备的传统的 "仅触摸" 设备
        (如手机和平板电脑)的情况下，用户可以将触摸屏与触控板、鼠标或键盘结合
        (conjunction)使用。因此，开发人员应避免将事件监听器与
        "要么是触摸要么是鼠标/键盘" 这类条件代码绑定，因为这会导致网站 /
        应用程序成为触摸独占(touch-exclusive)，
        从而阻止用户使用所有其他的输入机制。
      </p>
      <pre class="example"><code>
// 有条件的 "要么是触摸要么是鼠标/键盘" 事件绑定
// 不要这么做，因为这会使在那些支持触摸也支持
// 鼠标/键盘的设备的交互变成触摸独占

if ('ontouchstart' in window) {
  // 为触摸设置事件监听器
  target.addEventListener('touchend', ...);
  ...
} else {
  // 为鼠标/键盘设置事件监听器
  target.addEventListener('click', ...);
  ...
}
</code></pre>
      <p>
        相反，开发人员应该同时(concurrently)处理不同形式的输入。
      </p>
      <pre class="example"><code>
// 并发进行 "触摸和鼠标/键盘" 事件绑定

// 为触摸设置事件监听器
target.addEventListener('touchend', function(e) {
  // 阻止兼容性的鼠标事件和单击
  e.preventDefault();
  ...
});
...

// 为鼠标/键盘设置事件监听器
target.addEventListener('click', ...);
...
</code></pre>
      <p>
        为了避免因为一次的触摸行动处理两次相同的交互(一次用于触摸事件，
        一次用于兼容鼠标事件)，开发人员应确保 <a href="#dfn-canceled-event">
          取消</a> 触摸事件，从而阻止(suppressing)
        任何进一步的鼠标或单击事件的生成。另外，请参阅
        <a href="http://wicg.github.io/InputDeviceCapabilities/">
          InputDeviceCapabilities API</a> ，
        了解检测随着触摸事件触发而生成的鼠标事件的方法。
      </p>
    </div>
  </section>

  <section>
    <h2 id="glossary">术语表</h2>

    <dl>
      <dt><dfn>active touch point</dfn></dt>
      <dd>
        当前在屏幕上并由用户代理跟踪的 <a>touch point</a> 。当用户代理首次派发
        <a><code>touchstart</code></a> 事件表示其出现(appearance)时，
        触摸点就会变得活跃。在用户代理派发 <a><code>touchend</code></a> 或
        <a><code>touchcancel</code></a>
        事件表示触摸点从触摸平面移除或不再被跟踪后，触摸点不再活跃。
      </dd>

      <dt><dfn>touch point</dfn></dt>
      <dd>
        指针(如手指或触控笔)与界面的目标触摸平面相交的坐标点。
        常见场景有手指触摸触摸屏，或数字笔在纸上写字。
      </dd>

      <dt><dfn>canceled event</dfn></dt>
      <dd>
        一个事件，其默认行为通过 <code>preventDefault()</code> 阻止，
        在事件处理程序中返回 <code>false</code> ，或通过
        [[!DOM-LEVEL-3-EVENTS]] 和 [[!HTML5]] 定义的其他方式阻止。
      </dd>
    </dl>
  </section>

  <section class="appendix informative">
    <h2 id="acknowledgements">鸣谢</h2>
    <p>
      非常感谢 WebKit 工程师开发了作为本规范基础的模型，感谢 Neil Roberts
      (SitePen) 对 WebKit 触摸事件的总结，感谢 Peter Paul Koch (PPK)
      的撰写和建议，感谢 Robin Berjon 开发了
      <a href="http://dev.w3.org/2009/dap/ReSpec.js/documentation.html">
        ReSpec.js规范创作工具</a> ，感谢 WebEvents 工作组的众多贡献。
    </p>

    <p>
      随着规范的发展，许多人提出了另外的意见，这些意见促使了稳步的改进。
      其中包括 Matthew Schinckel 、 Andrew Grive 、 Cathy Chan 、 Boris Zbarsky
      、 Patrick H.Lauke 和 Simon Pieters 。如果我们无意中漏掉了你的名字，
      请告诉我。
    </p>

    <p>
      工作组感谢本规范的测试套件的贡献者: Matt Brubeck 、 Olli Pettay 、
      Art Barstow 、 Cathy Chan 和 Rick Byers 。
    </p>
  </section>

  <section class="appendix informative">
    <h2 id="changes-since-last-publication">自上次发布以来的更改</h2>
    <p>
      这是自 <a href="http://www.w3.org/TR/touch-events/">
        2013年10月10日的正式提案</a> 发布以来所做的主要修改的总结。
      同时提供
      <a href="https://github.com/w3c/touch-events/compare/v1...gh-pages">
        完整的提交历史记录</a> 。
    </p>
    <ul>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/125">Reword altitudeAngle/azimuthAngle descriptions in line
          with
          PointerEvents, add illustrations</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/120">Add getModifierState definition</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/303b36e1d188a380f9bc0861b175438e596a34b1">Added force
          attribute to Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/6d222fb7f106273bef847ad1d1d7a23569841954">Added radiusX and
          radiusY attributes to Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/487f6815a9590b72779d4820ff43c2b58d798f92">Added
          rotationAngle attribute to Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/006274ffada14de504f731afdb5ec1581ff327ca">Upgraded
          co-ordinates to double type instead of long</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/df620100e48111cf7a30592f344606f8c8b7fe22">Update touchmove
          behavior on preventDefault</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/54a3d1668c4f727d9c6f6d729b28a036041e301f">Clarify effect of
          canceling touchend event</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/219546b80cd148543a5ece656d81ba3c901d2106">Add constructor
          for TouchEvent and Touch</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/commit/50f51ccacb0d5ad06f9cf6ed44f853d6a3616d10">Added legacy event
          initializer initTouchEvent</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/59">Added support for uncancelable touch events and described
          scroll
          performance implications</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/67">Indicate that all events should be "composed".</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/72">Note about avoiding conditional "touch OR mouse/keyboard"
          event
          handling</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/73">Added TouchEvent's retargeting steps</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/81">Add touchType, altitudeAngle, azimuthAngle (Safari iOS
          10.3
          extensions for stylus)</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/88">Add [Exposed=Window] to Constructor</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/95">Add note to mention UA might adjusting touch target</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/96">Remove Legacy Event Initializers (createTouch and
          createTouchList)</a>
        and the
        <a href="https://github.com/w3c/touch-events/pull/100">note about initTouchEvent / createTouchList</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/111">Conditionally expose legacy touch events API</a>
      </li>
      <li>
        <a href="https://github.com/w3c/touch-events/pull/91">Add getModifierState definition to TouchEvent</a>
      </li>
    </ul>
  </section>
</body>
<script src="./custom-script.js" defer></script>

</html>